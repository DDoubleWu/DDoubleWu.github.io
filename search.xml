<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[PAT B 1041 考试座位号]]></title>
    <url>%2F2018%2F10%2F25%2FPAT-B-1041-%E8%80%83%E8%AF%95%E5%BA%A7%E4%BD%8D%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[（15分）每个 PAT 考生在参加考试时都会被分配两个座位号，一个是试机座位，一个是考试座位。正常情况下，考生在入场时先得到试机座位号码，入座进入试机状态后，系统会显示该考生的考试座位号码，考试时考生需要换到考试座位就座。但有些考生迟到了，试机已经结束，他们只能拿着领到的试机座位号码求助于你，从后台查出他们的考试座位号码。 输入格式：输入第一行给出一个正整数 N（≤1000），随后 N 行，每行给出一个考生的信息：准考证号 试机座位号 考试座位号。其中准考证号由 14 位数字组成，座位从 1 到 N 编号。输入保证每个人的准考证号都不同，并且任何时候都不会把两个人分配到同一个座位上。考生信息之后，给出一个正整数 M（≤N），随后一行中给出 M 个待查询的试机座位号码，以空格分隔。 输出格式：对应每个需要查询的试机座位号码，在一行中输出对应考生的准考证号和考试座位号码，中间用 1 个空格分隔。 输入样例：1234567410120150912233 2 410120150912119 4 110120150912126 1 310120150912002 3 223 4 输出样例：1210120150912002 210120150912119 1 代码123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;struct People &#123; char num[14]; int test, exam;&#125;admin[1000];int main()&#123; int N, M, i, j, n; cin &gt;&gt; N; for (i = 0; i&lt;N; i++) cin &gt;&gt; admin[i].num &gt;&gt; admin[i].test &gt;&gt; admin[i].exam; cin &gt;&gt; M; for (i = 0; i&lt;M; i++) &#123; cin &gt;&gt; n; for (j = 0; j&lt;N; j++) &#123; if (admin[j].test == n) cout &lt;&lt; admin[j].num &lt;&lt; ' ' &lt;&lt; admin[j].exam &lt;&lt; endl; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>C++</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT B 1039 到底买不买]]></title>
    <url>%2F2018%2F10%2F25%2FPAT-B-1039-%E5%88%B0%E5%BA%95%E4%B9%B0%E4%B8%8D%E4%B9%B0%2F</url>
    <content type="text"><![CDATA[（20分）小红想买些珠子做一串自己喜欢的珠串。卖珠子的摊主有很多串五颜六色的珠串，但是不肯把任何一串拆散了卖。于是小红要你帮忙判断一下，某串珠子里是否包含了全部自己想要的珠子？如果是，那么告诉她有多少多余的珠子；如果不是，那么告诉她缺了多少珠子。为方便起见，我们用[0-9]、[a-z]、[A-Z]范围内的字符来表示颜色。例如在图1中，第3串是小红想做的珠串；那么第1串可以买，因为包含了全部她想要的珠子，还多了8颗不需要的珠子；第2串不能买，因为没有黑色珠子，并且少了一颗红色的珠子。 输入格式：每个输入包含 1 个测试用例。每个测试用例分别在 2 行中先后给出摊主的珠串和小红想做的珠串，两串都不超过 1000 个珠子。 输出格式：如果可以买，则在一行中输出 Yes 以及有多少多余的珠子；如果不可以买，则在一行中输出 No 以及缺了多少珠子。其间以 1 个空格分隔。 输入样例 1：12ppRYYGrrYBR2258YrR8RrY 输出样例 1：1Yes 8 输入样例 2：12ppRYYGrrYB225YrR8RrY 输出样例 2：1No 2 关键点： 将所有字符转化为数字处理 代码:1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;int main()&#123; char s; int record[128] = &#123; 0 &#125;; //将所有字符转化为数字来处理 int more, less,i; more = less = 0; while ((s = getchar())!= '\n') record[(int)s]++; while ((s = getchar()) != '\n') record[(int)s]--; for (i = 0; i&lt;128; i++) &#123; if (record[i]&lt;0) less -= record[i]; else if (record[i]&gt;0) more += record[i]; &#125; if (less&gt;0) cout &lt;&lt; "No" &lt;&lt;' '&lt;&lt; less; else cout &lt;&lt; "Yes" &lt;&lt;' '&lt;&lt; more; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>C++</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT B 1038 统计同成绩学生]]></title>
    <url>%2F2018%2F10%2F24%2FPAT-B-1038-%E7%BB%9F%E8%AE%A1%E5%90%8C%E6%88%90%E7%BB%A9%E5%AD%A6%E7%94%9F%2F</url>
    <content type="text"><![CDATA[（20分）本题要求读入 N 名学生的成绩，将获得某一给定分数的学生人数输出。 输入格式：输入在第 1 行给出不超过 10​5​​ 的正整数 N，即学生总人数。随后一行给出 N 名学生的百分制整数成绩，中间以空格分隔。最后一行给出要查询的分数个数 K（不超过 N 的正整数），随后是 K 个分数，中间以空格分隔。 输出格式：在一行中按查询顺序给出得分等于指定分数的学生人数，中间以空格分隔，但行末不得有多余空格。 输入样例：1231060 75 90 55 75 99 82 90 75 503 75 90 88 输出样例：13 2 0 关键点： 最后一测试点N较大，代码需简洁 按查询顺序输出 代码：123456789101112131415161718192021#include &lt;cstdio&gt;using namespace std;int main()&#123; int i, N, K, num, s[101] = &#123; 0 &#125;; //num为成绩 scanf("%d", &amp;N); for (i = 0; i &lt; N; i++) &#123; scanf("%d", &amp;num); s[num]++; &#125; scanf("%d", &amp;K); for (i = 0; i &lt; K; i++) &#123; scanf("%d", &amp;num); if (i != K - 1) printf("%d ", s[num]); else printf("%d", s[num]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>C++</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT B 1037 在霍格沃茨找零钱]]></title>
    <url>%2F2018%2F10%2F24%2FPAT-B-1037-%E5%9C%A8%E9%9C%8D%E6%A0%BC%E6%B2%83%E8%8C%A8%E6%89%BE%E9%9B%B6%E9%92%B1%2F</url>
    <content type="text"><![CDATA[（20分）如果你是哈利·波特迷，你会知道魔法世界有它自己的货币系统 —— 就如海格告诉哈利的：“十七个银西可(Sickle)兑一个加隆(Galleon)，二十九个纳特(Knut)兑一个西可，很容易。”现在，给定哈利应付的价钱 P 和他实付的钱 A，你的任务是写一个程序来计算他应该被找的零钱。 输入格式：输入在 1 行中分别给出 P 和 A，格式为 Galleon.Sickle.Knut，其间用 1 个空格分隔。这里 Galleon 是 [0, 10​7​​] 区间内的整数，Sickle 是 [0, 17) 区间内的整数，Knut 是 [0, 29) 区间内的整数。 输出格式：在一行中用与输入同样的格式输出哈利应该被找的零钱。如果他没带够钱，那么输出的应该是负数。 输入样例 1：110.16.27 14.1.28 输出样例 1：13.2.1 输入样例 2：114.1.28 10.16.27 输出样例 2：1-3.2.1 关键点： 没带够钱的情况 代码：1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;using namespace std;int main()&#123; int G, S, K, g, s, k; int a, b, c,x,y,z; //a,b,c分别为加隆，银西可，纳克的值 scanf("%d.%d.%d", &amp;G, &amp;S, &amp;K); scanf("%d.%d.%d", &amp;g, &amp;s, &amp;k); //x,y,z存储g,s,k的值，即实付的金额 x = g; y = s; z = k; c = k - K; if (c&lt;0) &#123; s--; c += 29; &#125; b = s - S; if (b&lt;0) &#123; g--; b += 17; &#125; a = g - G; if(a&gt;=0) printf("%d.%d.%d", a, b, c); //没带够钱的情况 else &#123; c = K - z; if (c&lt;0) &#123; S--; c += 29; &#125; b = S - y; if (b&lt;0) &#123; G--; b += 17; &#125; a = G - x; printf("-%d.%d.%d", a, b, c); &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>C++</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT B 1036 跟奥巴马一起编程]]></title>
    <url>%2F2018%2F10%2F24%2FPAT-B-1036-%E8%B7%9F%E5%A5%A5%E5%B7%B4%E9%A9%AC%E4%B8%80%E8%B5%B7%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[（15分）美国总统奥巴马不仅呼吁所有人都学习编程，甚至以身作则编写代码，成为美国历史上首位编写计算机代码的总统。2014 年底，为庆祝“计算机科学教育周”正式启动，奥巴马编写了很简单的计算机代码：在屏幕上画一个正方形。现在你也跟他一起画吧！ 输入格式：输入在一行中给出正方形边长 N（3≤N≤20）和组成正方形边的某种字符 C，间隔一个空格。 输出格式：输出由给定字符 C 画出的正方形。但是注意到行间距比列间距大，所以为了让结果看上去更像正方形，我们输出的行数实际上是列数的 50%（四舍五入取整）。 输入样例：110 a 输出样例：12345aaaaaaaaaaa aa aa aaaaaaaaaaa 关键点： 四舍五入 习得的方法:c++数学取整函数(返回值为浮点型)，需头文件math.h: ceil(x):返回不小于x的最小整数值 floor(x):返回不大于x的最小整数值 round(x):四舍五入例：1234567891011#include &lt;math.h&gt;#include &lt;iostream&gt;using namespace std;int main()&#123; int x = 5; cout &lt;&lt; ceil(x / 2.0)&lt;&lt;endl; cout &lt;&lt; floor(x / 2.0)&lt;&lt;endl; cout &lt;&lt; round(x / 2.0)&lt;&lt;endl; return 0;&#125; 输出：123323 代码：1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;math.h&gt;using namespace std;int main()&#123; int N, i, j, num; char s; cin&gt;&gt;N&gt;&gt;s; num = (int)round(N/2.0); for (i = 0; i&lt;num; i++) &#123; if (i == 0 || i == num -1) &#123; for (j = 0; j&lt;N - 1; j++) cout &lt;&lt; s; cout &lt;&lt; s &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; s; for (j = 1; j&lt;N - 1; j++) cout &lt;&lt; ' '; cout &lt;&lt; s &lt;&lt; endl; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>C++</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT B 1032 挖掘机技术哪家强]]></title>
    <url>%2F2018%2F10%2F22%2FPAT-B-1032-%E6%8C%96%E6%8E%98%E6%9C%BA%E6%8A%80%E6%9C%AF%E5%93%AA%E5%AE%B6%E5%BC%BA%2F</url>
    <content type="text"><![CDATA[为了用事实说明挖掘机技术到底哪家强，PAT 组织了一场挖掘机技能大赛。现请你根据比赛结果统计出技术最强的那个学校。 输入格式：输入在第 1 行给出不超过 10​5​​ 的正整数 N，即参赛人数。随后 N 行，每行给出一位参赛者的信息和成绩，包括其所代表的学校的编号（从 1 开始连续编号）、及其比赛成绩（百分制），中间以空格分隔。 输出格式：在一行中给出总得分最高的学校的编号、及其总分，中间以空格分隔。题目保证答案唯一，没有并列。 输入样例：123456763 652 801 1002 703 403 0 输出样例：12 150 关键点： 最后一个测试点运行时间较长，代码需简洁 习得的知识点：简单声明数组不可将变量作为size，但vector可行123456#include &lt;vector&gt;int main()&#123; int n = 1000; vector&lt;int&gt; a(n);&#125; 代码：12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main()&#123; int N, i, n, m,max = 0; //m为total数组下标，max为队伍编号最大值 int max_s = 0; //max_s为最大总分 cin &gt;&gt; N; vector&lt;int&gt; num(N), score(N),total(N); for (i = 0; i&lt;N; i++) &#123; cin&gt;&gt;num[i]&gt;&gt;score[i]; if (max &lt; num[i]) max = num[i]; m = num[i]; total[m - 1] += score[i]; &#125; for (i = 0; i&lt;max; i++) &#123; if (max_s&lt;total[i]) &#123; max_s = total[i]; n = i + 1; &#125; &#125; cout &lt;&lt; n &lt;&lt; ' ' &lt;&lt; max_s; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>C++</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT B 1031 查验身份证]]></title>
    <url>%2F2018%2F10%2F22%2FPAT-B-1031-%E6%9F%A5%E9%AA%8C%E8%BA%AB%E4%BB%BD%E8%AF%81%2F</url>
    <content type="text"><![CDATA[（15分）一个合法的身份证号码由17位地区、日期编号和顺序编号加1位校验码组成。校验码的计算规则如下：首先对前17位数字加权求和，权重分配为：{7，9，10，5，8，4，2，1，6，3，7，9，10，5，8，4，2}；然后将计算的和对11取模得到值Z；最后按照以下关系对应Z值与校验码M的值：Z：0 1 2 3 4 5 6 7 8 9 10M：1 0 X 9 8 7 6 5 4 3 2现在给定一些身份证号码，请你验证校验码的有效性，并输出有问题的号码。 输入格式：输入第一行给出正整数N（≤100）是输入的身份证号码的个数。随后N行，每行给出1个18位身份证号码。 输出格式：按照输入的顺序每行输出1个有问题的身份证号码。这里并不检验前17位是否合理，只检查前17位是否全为数字且最后1位校验码计算准确。如果所有号码都正常，则输出All passed。 输入样例1：12345432012419880824005612010X19890101123411010819671130186637070419881216001X 输出样例1：12312010X19890101123411010819671130186637070419881216001X 输入样例2：1232320124198808240056110108196711301862 输出样例2：1All passed 关键点： 校验码的检验 X为10 出现的错误：看题看成了输出正确的… 代码123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; int N, i, j, z; int num, n; int por[17] = &#123; 7,9,10,5,8,4,2,1,6,3,7,9,10,5,8,4,2 &#125;; char M[11] = &#123; '1','0','X','9','8','7','6','5','4','3','2'&#125;; string str, s[100]; num = n = 0; cin &gt;&gt; N; for (i = 0; i&lt;N; i++) &#123; cin &gt;&gt; str; for (j = 0; j&lt;17; j++) &#123; if (str[j] == 'X') num += 10 * por[j]; else if (str[j]&gt;='0'&amp;&amp;str[j]&lt;='9') num += (str[j] - 48)*por[j]; else &#123; num = 0; s[n++] = str; break; &#125; &#125; if (num == 0) continue; else &#123; z = num % 11; if ( M[z] != str[17]) s[n++] = str; num = 0; &#125; &#125; if (n == 0) cout &lt;&lt; "All" &lt;&lt; ' '&lt;&lt; "passed"; else &#123; for (i = 0; i&lt;n; i++) cout &lt;&lt; s[i] &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>C++</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT B 1028 人口普查]]></title>
    <url>%2F2018%2F10%2F21%2FPAT-B-1028-%E4%BA%BA%E5%8F%A3%E6%99%AE%E6%9F%A5%2F</url>
    <content type="text"><![CDATA[（20分）某城镇进行人口普查，得到了全体居民的生日。现请你写个程序，找出镇上最年长和最年轻的人。这里确保每个输入的日期都是合法的，但不一定是合理的——假设已知镇上没有超过 200 岁的老人，而今天是 2014 年 9 月 6 日，所以超过 200 岁的生日和未出生的生日都是不合理的，应该被过滤掉。 输入格式：输入在第一行给出正整数 N，取值在(0,10​5​​]；随后 N 行，每行给出 1 个人的姓名（由不超过 5 个英文字母组成的字符串）以及按 yyyy/mm/dd（即年/月/日）格式给出的生日。题目保证最年长和最年轻的人没有并列。 输出格式：在一行中顺序输出有效生日的个数、最年长人和最年轻人的姓名，其间以空格分隔。 输入样例：1234565John 2001/05/12Tom 1814/09/06Ann 2121/01/30James 1814/09/05Steve 1967/11/20 输出样例：13 Tom John 关键点 年龄大小的比较 当没有符合要求的年龄时，输出为0 对输入的处理 习得知识点scanf的用法：参考文章：C语言函数详解对年月日大小的比较：参考文章: https://blog.csdn.net/daniel960601/article/details/55261196即year 10000 + month 100 + day，即可比较大小 代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdio&gt; #include &lt;string.h&gt;using namespace std;struct People &#123; char name[6]; int year, month, day; int total;&#125;p[100000];int main()&#123; int N, i, n = 0; int max, min; char old_name[6], young_name[6]; max = 0; min = 20140907; scanf("%d", &amp;N); for (i = 0; i&lt;N; i++) &#123; scanf("%s %d/%d/%d",&amp;p[i].name,&amp;p[i].year, &amp;p[i].month, &amp;p[i].day); p[i].total = p[i].year * 10000 + p[i].month * 100 + p[i].day; &#125; for (i = 0; i&lt;N; i++) &#123; if (p[i].total&gt;20140906 || p[i].total&lt;18140906) continue; else &#123; n++; if (p[i].total&gt;max) &#123; max = p[i].total; strcpy(young_name, p[i].name); &#125; if (p[i].total&lt;min) &#123; strcpy(old_name, p[i].name); min = p[i].total; &#125; &#125; &#125; if(n) printf("%d %s %s", n, old_name, young_name); else printf("0\n"); return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>C++</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT B 1021 个位数统计]]></title>
    <url>%2F2018%2F10%2F19%2FPAT-B-1021-%E4%B8%AA%E4%BD%8D%E6%95%B0%E7%BB%9F%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[（15分）给定一个 k 位整数 N=d​_{k−1}10​^{k−1}+⋯+d_110​^1​​+d_​0 (0≤d_{​i​​}≤9, i=0,⋯,k−1,d_{k−1​​}>0) 请编写程序统计每种不同的个位数字出现的次数。例如：给定 N=100311，则有 2 个 0，3 个 1，和 1 个 3。 输入格式：每个输入包含 1 个测试用例，即一个不超过 1000 位的正整数 N。 输出格式：对 N 中每一种不同的个位数字，以 D:M 的格式在一行中输出该位数字 D 及其在 N 中出现的次数 M。要求按 D 的升序输出。 输入样例：1100311 输出样例：1230:21:33:1 代码：12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; int num[10] = &#123; 0 &#125;; char dig[10] = &#123; '0','1','2','3','4','5','6','7','8','9' &#125;; string str; cin &gt;&gt; str; int i, j; for (i = 0; i&lt;str.size(); i++) &#123; for (j = 0; j&lt;10; j++) &#123; if (dig[j] == str[i]) &#123; num[j]++; break; &#125; &#125; &#125; for (i = 0; i&lt;10; i++) &#123; if(num[i]!=0) cout &lt;&lt; i &lt;&lt; ':' &lt;&lt; num[i] &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>C++</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT B 1020 月饼]]></title>
    <url>%2F2018%2F10%2F18%2FPAT-B-1020-%E6%9C%88%E9%A5%BC%2F</url>
    <content type="text"><![CDATA[(25分）月饼是中国人在中秋佳节时吃的一种传统食品，不同地区有许多不同风味的月饼。现给定所有种类月饼的库存量、总售价、以及市场的最大需求量，请你计算可以获得的最大收益是多少。注意：销售时允许取出一部分库存。样例给出的情形是这样的：假如我们有 3 种月饼，其库存量分别为 18、15、10 万吨，总售价分别为 75、72、45 亿元。如果市场的最大需求量只有 20 万吨，那么我们最大收益策略应该是卖出全部 15 万吨第 2 种月饼、以及 5 万吨第 3 种月饼，获得 72 + 45/2 = 94.5（亿元）。 输入格式：每个输入包含一个测试用例。每个测试用例先给出一个不超过 1000 的正整数 N 表示月饼的种类数、以及不超过 500（以万吨为单位）的正整数 D 表示市场最大需求量。随后一行给出 N 个正数表示每种月饼的库存量（以万吨为单位）；最后一行给出 N 个正数表示每种月饼的总售价（以亿元为单位）。数字间以空格分隔。 输出格式：对每组测试用例，在一行中输出最大收益，以亿元为单位并精确到小数点后 2 位。 输入样例：1233 2018 15 1075 72 45 输出样例：194.50 关键点： 精确到小数点后两位 库存与需求的关系 习得知识点：排序函数sort(begin,end,cmp)，其参数cmp的用法如下：1234567891011121314#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;bool cmp(int a, int b) &#123; return a&lt;b; //此为默认升序，若为降序，只需&gt;即可&#125;int main()&#123; int A[5] = &#123; 5,3,1,2,4 &#125;; sort(A, A + 5, cmp); for (int i = 0; i &lt; 5; i++) cout &lt;&lt; A[i] &lt;&lt; ' '; return 0;&#125; 代码：123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;algorithm&gt;using namespace std;struct Mooncake&#123; double num,total_p,unit_p; //库存量，总售价，单价&#125;cakes[1000];bool cmp(Mooncake a,Mooncake b)&#123; return a.unit_p&gt;b.unit_p; //降序&#125;int main()&#123; int i,n,maxd; double max_earn; cin&gt;&gt;n&gt;&gt;maxd; for (i=0;i&lt;n;i++) cin&gt;&gt;cakes[i].num; for (i=0;i&lt;n;i++) cin&gt;&gt;cakes[i].total_p; for (i=0;i&lt;n;i++) cakes[i].unit_p = cakes[i].total_p/cakes[i].num; sort(cakes,cakes+n,cmp); for(i=0;i&lt;n;i++) &#123; if(maxd&lt;=cakes[i].num) &#123; max_earn += cakes[i].unit_p * maxd; break; &#125; else &#123; max_earn += cakes[i].unit_p * cakes[i].num; maxd -= cakes[i].num; &#125; &#125; cout&lt;&lt;setiosflags(ios::fixed)&lt;&lt;setprecision(2)&lt;&lt;max_earn; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>C++</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT B 1019 数字黑洞]]></title>
    <url>%2F2018%2F10%2F18%2FPAT-B-1019-%E6%95%B0%E5%AD%97%E9%BB%91%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[给定任一个各位数字不完全相同的 4 位正整数，如果我们先把 4 个数字按非递增排序，再按非递减排序，然后用第 1 个数字减第 2 个数字，将得到一个新的数字。一直重复这样做，我们很快会停在有“数字黑洞”之称的 6174，这个神奇的数字也叫 Kaprekar 常数。例如，我们从6767开始，将得到1234567766 - 6677 = 10899810 - 0189 = 96219621 - 1269 = 83528532 - 2358 = 61747641 - 1467 = 6174... ... 现给定任意 4 位正整数，请编写程序演示到达黑洞的过程。 输入格式：输入给出一个 (0,104​) 区间内的正整数 N。 输出格式：如果 N 的 4 位数字全相等，则在一行内输出 N - N = 0000；否则将计算的每一步在一行内输出，直到 6174 作为差出现，输出格式见样例。注意每个数字按 4 位数格式输出。 输入样例 1：16767 输出样例 1：12347766 - 6677 = 10899810 - 0189 = 96219621 - 1269 = 83528532 - 2358 = 6174 输入样例 2：12222 输出样例 2：12222 - 2222 = 0000 关键点： 每个数字按4位输出 对数字各位排序 习得知识点：sort()函数参考文章： C++sort函数的使用总结sort()函数：对给定区间所有元素进行排序需头文件alogorithm 语法描述123sort(begin,end,cmp) //cmp参数可以没有，如果没有默认为非降序排序sort(begin,end,less&lt;data-type&gt;()); //升序sort(begin,end,greater&lt;data-type&gt;()); //降序 举例：123456789101112#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; int A[5] = &#123; 1,5,3,4,2 &#125;; sort(A, A + 5); //升序 for (int i = 0; i&lt;5; i++) cout &lt;&lt; A[i] &lt;&lt; ' '; return 0;&#125; 输出：11 2 3 4 5 输出指定位数采用printf()函数,需头文件cstdio1234printf("a=%4d\n",a); //输出4位十进制整数，左边补空格printf("a=%04d\n",a); //输出4位十进制整数，左边补0printf("a=%-4d\n",a); //输出4位十进制整数，右边补空格printf("s[]=%s\n",s); //输出数组字符串 代码：注意:在vs中调试scanf需改为scanf_s123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int trans_arr(int A[]);void trans_num(int n, int A[]);int main()&#123; int num, origin, n = 0; scanf("%d", &amp;num); int A[4]; int res, max, min; res = max = min = 1; origin = num; trans_num(num, A); while (res != 6174) &#123; sort(A, A + 4, less&lt;int&gt;()); min = trans_arr(A); sort(A, A + 4, greater&lt;int&gt;()); max = trans_arr(A); res = max - min; //当所有数字相等时 if (res == 0) &#123; printf("%04d - %04d = %04d\n", origin, origin, 0); return 0; &#125; printf("%04d - %04d = %04d\n", max, min, res); num = res; trans_num(num, A); &#125; return 0;&#125;int trans_arr(int A[]) //将数组转化为数字&#123; int num = 0; for (int i = 0; i &lt; 4; i++) &#123; num = num * 10 + A[i]; &#125; return num;&#125;void trans_num(int n,int A[]) //将数字转化为数组&#123; for (int i = 0; i &lt; 4; i++) &#123; A[i] = n % 10; n = n / 10; &#125;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>C++</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT B 1018 锤子剪刀布]]></title>
    <url>%2F2018%2F10%2F17%2FPAT-B-%E9%94%A4%E5%AD%90%E5%89%AA%E5%88%80%E5%B8%83%2F</url>
    <content type="text"><![CDATA[大家应该都会玩“锤子剪刀布”的游戏：两人同时给出手势，现给出两人的交锋记录，请统计双方的胜、平、负次数，并且给出双方分别出什么手势的胜算最大。 输入格式：输入第 1 行给出正整数 N（≤10​5​​），即双方交锋的次数。随后 N 行，每行给出一次交锋的信息，即甲、乙双方同时给出的的手势。C 代表“锤子”、J 代表“剪刀”、B 代表“布”，第 1 个字母代表甲方，第 2 个代表乙方，中间有 1 个空格。 输出格式：输出第 1、2 行分别给出甲、乙的胜、平、负次数，数字间以 1 个空格分隔。第 3 行给出两个字母，分别代表甲、乙获胜次数最多的手势，中间有 1 个空格。如果解不唯一，则输出按字母序最小的解。 输入样例：123456789101110C JJ BC BB BB CC CC BJ BB CJ J 输出样例：1235 3 22 3 5B B 关键点： 若相等，输出按字母序最小的解 解决方法：建立一sign[3]数组，在其中将字母序已经排好，当次数不等时，比较得出最大项，存储其下标，若相等，则下标值默认不变，即可按照字母序输出 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;using namespace std;int main()&#123; int N, i; cin &gt;&gt; N; int equal = 0; int win, lose,m = 0; char A[100000], B[100000]; int num[6] = &#123; 0 &#125;; char sign[3] = &#123; 'B','C','J' &#125;; //输入对阵记录 for (i = 0; i&lt;N; i++) &#123; cin &gt;&gt; A[i] &gt;&gt; B[i]; &#125; for (i = 0; i&lt;N; i++) &#123; if (A[i] == B[i]) &#123; equal++; &#125; else if (A[i] == 'C') &#123; if( B[i]=='J') num[1]++; else num[3]++; &#125; else if (A[i] == 'J') &#123; if (B[i]=='B') num[2]++; else num[4]++; &#125; else if (A[i] == 'B') &#123; if (B[i]=='C') num[0]++; else num[5]++; &#125; &#125; win = num[1] + num[0] + num[2]; lose = num[3]+num[4]+num[5]; cout &lt;&lt; win &lt;&lt; ' ' &lt;&lt; equal &lt;&lt; ' ' &lt;&lt; lose &lt;&lt; endl; cout &lt;&lt; lose &lt;&lt; ' ' &lt;&lt; equal &lt;&lt; ' ' &lt;&lt; win &lt;&lt; endl; int max = 0; //处理相等时情况 for (i = 0; i&lt;3; i++) &#123; if (max &lt; num[i]) &#123; max = num[i]; m = i; &#125; &#125; cout &lt;&lt; sign[m] &lt;&lt; ' '; max = 0; m = 0; for (i=3;i&lt;6;i++) &#123; if (max &lt; num[i]) &#123; max = num[i]; m = i-3; &#125; &#125; cout&lt;&lt;sign[m]; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>C++</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT B 1017 A除以B]]></title>
    <url>%2F2018%2F10%2F17%2FPAT-B-1017-A%E9%99%A4%E4%BB%A5B%2F</url>
    <content type="text"><![CDATA[本题要求计算 A/B，其中 A 是不超过 1000 位的正整数，B 是 1 位正整数。你需要输出商数 Q 和余数 R，使得 A=B×Q+R 成立。 输入格式：输入在一行中依次给出 A 和 B，中间以 1 空格分隔。 输出格式：在一行中依次输出 Q 和 R，中间以 1 空格分隔。 输入样例：1123456789050987654321 7 输出样例：117636684150141093474 3 关键点: 处理1000位正整数的计算 商数为0的情况 将字符转化为数字 解决方法：将其转化为除法计算，通过’0’-48这种方式将字符转化为数字，不断进位计算 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; string A; int i, B, rem; int n, digit; //digit为每一次的被除数，n为数组元素的个数 n = digit = 0; int flag = 1; //做标记 cin &gt;&gt; A &gt;&gt; B; int num[1000]; for (i = 0; A[i] != '\0'; i++) &#123; digit += (A[i] - 48); //字符转化为数字 if (digit == B) &#123; num[n++] = 1; rem = digit = 0; &#125; else if (digit &lt; B) &#123; rem = digit; digit = digit * 10; num[n++] = 0; &#125; else &#123; if (digit % B == 0) &#123; num[n++] = digit / B; rem = 0; digit = 0; &#125; else &#123; num[n++] = digit / B; rem = digit % B; digit = rem * 10; &#125; &#125; &#125; if (n == 1) &#123; cout &lt;&lt; num[0] &lt;&lt; ' ' &lt;&lt; rem; return 0; &#125; for (i = 0; i&lt;n; i++) &#123; //从第一个非0的数开始输出 if (num[i] == 0 &amp;&amp; flag == 1) continue; else &#123; cout &lt;&lt; num[i]; flag = 0; &#125; &#125; cout &lt;&lt; ' ' &lt;&lt; rem; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>C++</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT B 1013 数素数]]></title>
    <url>%2F2018%2F10%2F17%2FPAT-B-1013-%E6%95%B0%E7%B4%A0%E6%95%B0%2F</url>
    <content type="text"><![CDATA[令 P​i​​ 表示第 i 个素数。现任给两个正整数 M≤N≤104，请输出PM​​​​ 到PN的所有素数。 输入格式：输入在一行中给出 M 和 N，其间以空格分隔。 输出格式：输出从 P​ 到 P​ 的所有素数，每 10 个数字占 1 行，其间以空格分隔，但行末不得有多余空格。 输入样例：15 27 输出样例：12311 13 17 19 23 29 31 37 41 4347 53 59 61 67 71 73 79 83 8997 101 103 关键点: 判定素数 每十个数字一行 行末不得有多余空格 习得知识点:素数的判定，只需查找至sqrt(num)即可用法:123456789101112131415#include &lt;math.h&gt;#include &lt;iostream&gt;using namespace std;int main()&#123; int num = 25; int flag = 1; //做标记 for (int i = 2; i&lt;sqrt(num); i++) &#123; if (num%i == 0) &#123; flag = 0; break; &#125; &#125; if (flag == 0) cout &lt;&lt; num &lt;&lt; "不是素数" &lt;&lt; endl; else cout &lt;&lt; num &lt;&lt; "是素数" &lt;&lt; endl; return 0;&#125; 代码:123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;math.h&gt;using namespace std;int main()&#123; int M, N; cin &gt;&gt; M &gt;&gt; N; int flag = 1; //做标记 int n = 1; //素数个数 int i, num = 3; int pr_num[10000] = &#123;0&#125;; pr_num[0] = 2; while (n&lt;10000) &#123; //判定素数 for (i = 2; i&lt;=sqrt(num); i++) &#123; if (num%i == 0) &#123; flag = 0; break; &#125; &#125; if (flag == 1) pr_num[n++] = num; else flag = 1; num++; &#125; n = 1; for (i = M-1; i&lt;N-1; i++) &#123; //每十个一行 if (n % 10 == 0) cout &lt;&lt; pr_num[i] &lt;&lt; endl; else cout &lt;&lt; pr_num[i] &lt;&lt; ' '; n++; &#125; cout &lt;&lt; pr_num[i]; //行末无空格 return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>C++</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT B 1012 数字分类]]></title>
    <url>%2F2018%2F10%2F17%2FPAT-B-1012-%E6%95%B0%E5%AD%97%E5%88%86%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[给定一系列正整数，请按要求对数字进行分类，并输出以下 5 个数字： A​1​​ = 能被 5 整除的数字中所有偶数的和； A​2​​ = 将被 5 除后余 1 的数字按给出顺序进行交错求和，即计算 n​1​​−n​2​​+n​3​​−n​4​​⋯； A​3​​ = 被 5 除后余 2 的数字的个数； A​4​​ = 被 5 除后余 3 的数字的平均数，精确到小数点后 1 位； A​5​​ = 被 5 除后余 4 的数字中最大数字。 输入格式：每个输入包含 1 个测试用例。每个测试用例先给出一个不超过 1000 的正整数 N，随后给出 N 个不超过 1000 的待分类的正整数。数字间以空格分隔。 输出格式：对给定的 N 个正整数，按题目要求计算 A​1​​~A​5​​ 并在一行中顺序输出。数字间以空格分隔，但行末不得有多余空格。若其中某一类数字不存在，则在相应位置输出 N。 输入样例 1：113 1 2 3 4 5 6 7 8 9 10 20 16 18 输出样例 1130 11 2 9.7 9 输入样例 2：18 1 2 4 5 6 7 9 16 输出样例 2：1N 11 2 N 9 关键点： 精确到小数点后一位 行末不得有多余的空格 A2可能出现求和为0的情况，但此时有数字满足A2条件 习得知识点：采用头文件iomanip下的setprecision()用法精确位数用法：123#include &lt;iomanip&gt;double a = 2.3333;cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(3) &lt;&lt; a; //精确到小数点后三位 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;iomanip&gt;using namespace std;int main()&#123; int i, N,b; double num = 0; cin &gt;&gt; N; int k = 0; int a[5] = &#123;0&#125;; int flag = 0; for(i=0;i&lt;N;i++) &#123; cin &gt;&gt; b; if (b % 5 == 0 &amp;&amp; b%2==0) a[0] += b; else if (b % 5 == 1) &#123; if (flag == 0) &#123; a[1] += b; flag = 1; &#125; else &#123; a[1] -= b; flag = 0; &#125; k++; &#125; else if (b % 5 == 2) a[2] += 1; else if (b % 5 == 3) &#123; num += 1.0; a[3] += b; &#125; else if (b % 5 ==4) &#123; if (a[4]&lt;b) a[4] = b; &#125; &#125; for (i = 0; i&lt;4; i++) &#123; if (k&gt;0&amp;&amp;i==1&amp;&amp;a[i]==0) cout&lt;&lt; 0&lt;&lt;' '; //针对关键点3 else if (a[i] == 0) cout &lt;&lt; 'N' &lt;&lt; ' '; else if (i == 3) cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(1) &lt;&lt; a[i]/num &lt;&lt;' '; //针对关键点2，精确到小数点后一位 else cout &lt;&lt; a[i] &lt;&lt; ' '; &#125; //行末无空格 if (a[i] == 0) cout &lt;&lt; 'N'; else cout &lt;&lt; a[i]; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>C++</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++数组]]></title>
    <url>%2F2018%2F10%2F07%2FC-%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[创建数组数组是一种数据格式，能够存储多个同类型的数值，每个值都存储在一个独立的数组元素中，计算机在内存中依次存储数组的各个元素。要创建数组，可使用声明语句，数组声明应指出一下三点： 存储在每个元素中的值的类型 数组名 数组中的元素数 简单变量声明使用数组声明来创建数组时，将采用静态联编，即数组长度在编译时设置该种声明数组的通用格式如下：1typename arrayName[arraySize]; 表达式arraySize指定元素数目，可以是整形常数（如10）或const值，也可以是常量表达式（如 8*sizeof(int)），即arraySize不能是变量。ex：1int days[10]; 数组的初始化只有在定义数组的时候才可初始化，不能将一个数组赋给另一个数组：123int months[5] = &#123;1,2,3,4,5&#125;; //okayint months[5]; //okayint *p = years[5]; //okay 初始化数组时，提供的值可以少于数组的元素数目，如果只对数组的一部分进行初始化，则编译器把其他元素设为0:12int days[10] = &#123;1,2&#125;; //前两个元素为0int cards[5] = &#123;0&#125;; //全部为0 若初始化数组时arraySize为空，C++编译器将计算元素个数。ex:1short things[] = &#123;1,3,5,8&#125;; //编译器将使其things数组包含4个元素 C++11数组的初始化方法C++11中的列表初始化增加了一些功能1.初始化数组时，可以省略等号（=)1short things[4] &#123;1,2,3,4&#125;; 2.可在大括号中不包含任何东西，将所有元素设置为01float cards[4] &#123;&#125;; 3.列表初始化禁止缩窄转换12long plifs[] = &#123;25,92,3.0&#125;; //not allowedchar tlifs[] = &#123;'h','j',112&#125;; //allowed 第一条不能通过编译，因为浮点型转化为整型时缩窄操作第二条语句可以通过编译，因为虽然112是一个int值，但它在char变量的取值范围内(-128~127) 使用new创建动态数组采用new[]运算符创建数组时，将采用动态联编，即在运行时为数组分配空间，其长度也将在运行时设置。 初始化数组在C++中，只需要将数组的元素类型和元素数目告诉new即可ex:1int *p = new int [10]; //创建一个包含10个int元素的数组 new运算符返回第一个元素的地址当程序使用完new分配的内存块时，应使用delete来释放它们。对于new创建的数组，应使用以下delete来释放：1delete [] p; //方括号表示释放整个数组 如果new一个实体分配内存，则应使用delete(没有方括号)来释放 数组的使用对于第一个元素，可以使用p[0],第二个元素为p[1]ex:1234double *p = new double [2];p[0] = 1.0;p[1] = 2.0;delete [] p; 模板类vector创建vector初始化模板类vector也是一种动态数组，可以在末尾添加新数据，还可以在中间添加新数据，基本上是使用new创建动态数组的替代品，要创建vector模板对象，可使用通常的表示法来指出要使用的类型，还可用初始化参数来指出需要多少矢量ex:123456#include &lt;vector&gt;using namespace std;vector&lt;int&gt; ratings(5);int n;cin&gt;&gt;n;vector&lt;double&gt; scores(n); 由于运算符[]被重载，因此创建vector对象后，可以使用通常的数组表示法来访问每个元素:123retings[0] = 9;for (int i=0;i&lt;n;i++) cout&lt;&lt;scores[i]&lt;&lt;endl; vector基本用法所有STL容器都提供了一些基本方法，其中包括size()——返回容器中元素数目,swap()——交换两个容器的内容,begin()——返回一个指向容器中第一个元素的迭代器,end()——返回一个表示超过容器尾的迭代器。 添加元素采用 push_back()可以将元素添加到末尾ex:1234vector&lt;double&gt; scores;double temp;while (cin&gt;&gt;temp &amp;&amp; temp &gt;=0) scores.push_back(temp); 这样每次循环都会给scores对象添加一个元素，在编写或运程序时，无需了解元素的数目。只要能够取得足够的内存，程序就可以增加scores的长度。 删除元素采用erase()方法删除矢量中给定区间的元素，他接受两个迭代器参数，这些参数定义了要删除的区间。第一个迭代器指向区间的起始处，第二个迭代器位于区间终止处的后一个位置。ex:1scores.erase(scores.begin(),scores.begin()+2) //删除begin()到begin()+1的元素 该区间为前闭后开，即[begin(),end()]包含的内容为[p1,p2) 插入元素使用insert()方法插入元素，insert()接收3个参数，第一个参数指定了新元素的插入位置，第二个和第三个迭代器参数定义了被插入区间，下面的代码将矢量new_d中除第一个元素外的所有元素插入到old_v矢量的第一个元素前面:1old_v.insert(old_v.begin(),new_v.begin()+1,new_v.end());]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>笔记</tag>
        <tag>基础</tag>
      </tags>
  </entry>
</search>
