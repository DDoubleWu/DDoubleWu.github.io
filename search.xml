<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[PAT B 1013 数素数]]></title>
    <url>%2F2018%2F10%2F17%2FPAT-B-1013-%E6%95%B0%E7%B4%A0%E6%95%B0%2F</url>
    <content type="text"><![CDATA[1013 数素数（20分）令 P​i​​ 表示第 i 个素数。现任给两个正整数 M≤N≤10​4​​，请输出 P​M​​ 到 P​N​​ 的所有素数。 输入格式：输入在一行中给出 M 和 N，其间以空格分隔。 输出格式：输出从 P​M​​ 到 P​N​​ 的所有素数，每 10 个数字占 1 行，其间以空格分隔，但行末不得有多余空格。 输入样例：15 27 输出样例：12311 13 17 19 23 29 31 37 41 4347 53 59 61 67 71 73 79 83 8997 101 103 关键点: 判定素数 每十个数字一行 行末不得有多余空格 习得知识点:素数的判定，只需查找至sqrt(num)即可用法:123456789101112131415#include &lt;math.h&gt;#include &lt;iostream&gt;using namespace std;int main()&#123; int num = 25; int flag = 1; //做标记 for (int i = 2; i&lt;sqrt(num); i++) &#123; if (num%i == 0) &#123; flag = 0; break; &#125; &#125; if (flag == 0) cout &lt;&lt; num &lt;&lt; "不是素数" &lt;&lt; endl; else cout &lt;&lt; num &lt;&lt; "是素数" &lt;&lt; endl; return 0;&#125; 代码:123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;math.h&gt;using namespace std;int main()&#123; int M, N; cin &gt;&gt; M &gt;&gt; N; int flag = 1; //做标记 int n = 1; //素数个数 int i, num = 3; int pr_num[10000] = &#123;0&#125;; pr_num[0] = 2; while (n&lt;10000) &#123; //判定素数 for (i = 2; i&lt;=sqrt(num); i++) &#123; if (num%i == 0) &#123; flag = 0; break; &#125; &#125; if (flag == 1) pr_num[n++] = num; else flag = 1; num++; &#125; n = 1; for (i = M-1; i&lt;N-1; i++) &#123; //每十个一行 if (n % 10 == 0) cout &lt;&lt; pr_num[i] &lt;&lt; endl; else cout &lt;&lt; pr_num[i] &lt;&lt; ' '; n++; &#125; cout &lt;&lt; pr_num[i]; //行末无空格 return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>PAT</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT B 1012 数字分类]]></title>
    <url>%2F2018%2F10%2F17%2FPAT-B-1012-%E6%95%B0%E5%AD%97%E5%88%86%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[1012 数字分类（20分)给定一系列正整数，请按要求对数字进行分类，并输出以下 5 个数字： A​1​​ = 能被 5 整除的数字中所有偶数的和； A​2​​ = 将被 5 除后余 1 的数字按给出顺序进行交错求和，即计算 n​1​​−n​2​​+n​3​​−n​4​​⋯； A​3​​ = 被 5 除后余 2 的数字的个数； A​4​​ = 被 5 除后余 3 的数字的平均数，精确到小数点后 1 位； A​5​​ = 被 5 除后余 4 的数字中最大数字。 输入格式：每个输入包含 1 个测试用例。每个测试用例先给出一个不超过 1000 的正整数 N，随后给出 N 个不超过 1000 的待分类的正整数。数字间以空格分隔。 输出格式：对给定的 N 个正整数，按题目要求计算 A​1​​~A​5​​ 并在一行中顺序输出。数字间以空格分隔，但行末不得有多余空格。若其中某一类数字不存在，则在相应位置输出 N。 输入样例 1：113 1 2 3 4 5 6 7 8 9 10 20 16 18 输出样例 1130 11 2 9.7 9 输入样例 2：18 1 2 4 5 6 7 9 16 输出样例 2：1N 11 2 N 9 关键点： 精确到小数点后一位 行末不得有多余的空格 A2可能出现求和为0的情况，但此时有数字满足A2条件 习得知识点：采用头文件iomanip下的cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision()用法精确位数用法：123#include &lt;iomanip&gt;double a = 2.3333;cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(3) &lt;&lt; a; //精确到小数点后三位 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;iomanip&gt;using namespace std;int main()&#123; int i, N,b; double num = 0; cin &gt;&gt; N; int k = 0; int a[5] = &#123;0&#125;; int flag = 0; for(i=0;i&lt;N;i++) &#123; cin &gt;&gt; b; if (b % 5 == 0 &amp;&amp; b%2==0) a[0] += b; else if (b % 5 == 1) &#123; if (flag == 0) &#123; a[1] += b; flag = 1; &#125; else &#123; a[1] -= b; flag = 0; &#125; k++; &#125; else if (b % 5 == 2) a[2] += 1; else if (b % 5 == 3) &#123; num += 1.0; a[3] += b; &#125; else if (b % 5 ==4) &#123; if (a[4]&lt;b) a[4] = b; &#125; &#125; for (i = 0; i&lt;4; i++) &#123; if (k&gt;0&amp;&amp;i==1&amp;&amp;a[i]==0) cout&lt;&lt; 0&lt;&lt;' '; //针对关键点3 else if (a[i] == 0) cout &lt;&lt; 'N' &lt;&lt; ' '; else if (i == 3) cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(1) &lt;&lt; a[i]/num &lt;&lt;' '; //针对关键点2，精确到小数点后一位 else cout &lt;&lt; a[i] &lt;&lt; ' '; &#125; //行末无空格 if (a[i] == 0) cout &lt;&lt; 'N'; else cout &lt;&lt; a[i]; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>笔记</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++数组]]></title>
    <url>%2F2018%2F10%2F07%2FC-%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[创建数组数组是一种数据格式，能够存储多个同类型的数值，每个值都存储在一个独立的数组元素中，计算机在内存中依次存储数组的各个元素。要创建数组，可使用声明语句，数组声明应指出一下三点： 存储在每个元素中的值的类型 数组名 数组中的元素数 简单变量声明使用数组声明来创建数组时，将采用静态联编，即数组长度在编译时设置该种声明数组的通用格式如下：1typename arrayName[arraySize]; 表达式arraySize指定元素数目，可以是整形常数（如10）或const值，也可以是常量表达式（如 8*sizeof(int)），即arraySize不能是变量。ex：1int days[10]; 数组的初始化只有在定义数组的时候才可初始化，不能将一个数组赋给另一个数组：123int months[5] = &#123;1,2,3,4,5&#125;; //okayint months[5]; //okayint *p = years[5]; //okay 初始化数组时，提供的值可以少于数组的元素数目，如果只对数组的一部分进行初始化，则编译器把其他元素设为0:12int days[10] = &#123;1,2&#125;; //前两个元素为0int cards[5] = &#123;0&#125;; //全部为0 若初始化数组时arraySize为空，C++编译器将计算元素个数。ex:1short things[] = &#123;1,3,5,8&#125;; //编译器将使其things数组包含4个元素 C++11数组的初始化方法C++11中的列表初始化增加了一些功能1.初始化数组时，可以省略等号（=)1short things[4] &#123;1,2,3,4&#125;; 2.可在大括号中不包含任何东西，将所有元素设置为01float cards[4] &#123;&#125;; 3.列表初始化禁止缩窄转换12long plifs[] = &#123;25,92,3.0&#125;; //not allowedchar tlifs[] = &#123;'h','j',112&#125;; //allowed 第一条不能通过编译，因为浮点型转化为整型时缩窄操作第二条语句可以通过编译，因为虽然112是一个int值，但它在char变量的取值范围内(-128~127) 使用new创建动态数组采用new[]运算符创建数组时，将采用动态联编，即在运行时为数组分配空间，其长度也将在运行时设置。 初始化数组在C++中，只需要将数组的元素类型和元素数目告诉new即可ex:1int *p = new int [10]; //创建一个包含10个int元素的数组 new运算符返回第一个元素的地址当程序使用完new分配的内存块时，应使用delete来释放它们。对于new创建的数组，应使用以下delete来释放：1delete [] p; //方括号表示释放整个数组 如果new一个实体分配内存，则应使用delete(没有方括号)来释放 数组的使用对于第一个元素，可以使用p[0],第二个元素为p[1]ex:1234double *p = new double [2];p[0] = 1.0;p[1] = 2.0;delete [] p; 模板类vector创建vector初始化模板类vector也是一种动态数组，可以在末尾添加新数据，还可以在中间添加新数据，基本上是使用new创建动态数组的替代品，要创建vector模板对象，可使用通常的表示法来指出要使用的类型，还可用初始化参数来指出需要多少矢量ex:123456#include &lt;vector&gt;using namespace std;vector&lt;int&gt; ratings(5);int n;cin&gt;&gt;n;vector&lt;double&gt; scores(n); 由于运算符[]被重载，因此创建vector对象后，可以使用通常的数组表示法来访问每个元素:123retings[0] = 9;for (int i=0;i&lt;n;i++) cout&lt;&lt;scores[i]&lt;&lt;endl; vector基本用法所有STL容器都提供了一些基本方法，其中包括size()——返回容器中元素数目,swap()——交换两个容器的内容,begin()——返回一个指向容器中第一个元素的迭代器,end()——返回一个表示超过容器尾的迭代器。 添加元素采用 push_back()可以将元素添加到末尾ex:1234vector&lt;double&gt; scores;double temp;while (cin&gt;&gt;temp &amp;&amp; temp &gt;=0) scores.push_back(temp); 这样每次循环都会给scores对象添加一个元素，在编写或运程序时，无需了解元素的数目。只要能够取得足够的内存，程序就可以增加scores的长度。 删除元素采用erase()方法删除矢量中给定区间的元素，他接受两个迭代器参数，这些参数定义了要删除的区间。第一个迭代器指向区间的起始处，第二个迭代器位于区间终止处的后一个位置。ex:1scores.erase(scores.begin(),scores.begin()+2) //删除begin()到begin()+1的元素 该区间为前闭后开，即[begin(),end()]包含的内容为[p1,p2) 插入元素使用insert()方法插入元素，insert()接收3个参数，第一个参数指定了新元素的插入位置，第二个和第三个迭代器参数定义了被插入区间，下面的代码将矢量new_d中除第一个元素外的所有元素插入到old_v矢量的第一个元素前面:1old_v.insert(old_v.begin(),new_v.begin()+1,new_v.end());]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>基础</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
</search>
