{"meta":{"title":"DDoubleWu的博客","subtitle":"吴会玩","description":"致力于成为程序猿的菜鸟","author":"DDoubleWu","url":"https://ddoublewu.github.io"},"pages":[{"title":"Hello WOrld!","date":"2018-10-04T01:22:14.000Z","updated":"2018-10-04T01:22:14.120Z","comments":true,"path":"Hello-WOrld/index.html","permalink":"https://ddoublewu.github.io/Hello-WOrld/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-10-05T10:39:54.000Z","updated":"2018-10-05T10:42:33.144Z","comments":false,"path":"categories/index.html","permalink":"https://ddoublewu.github.io/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2018-10-05T10:40:10.000Z","updated":"2018-10-05T10:42:49.652Z","comments":false,"path":"about/index.html","permalink":"https://ddoublewu.github.io/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-10-07T02:01:13.000Z","updated":"2018-10-07T02:01:13.947Z","comments":true,"path":"tags/index-1.html","permalink":"https://ddoublewu.github.io/tags/index-1.html","excerpt":"","text":""},{"title":"tags","date":"2018-10-05T10:39:35.000Z","updated":"2018-10-05T10:42:17.024Z","comments":false,"path":"tags/index.html","permalink":"https://ddoublewu.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"数据结构 (7)图","slug":"数据结构-7-图","date":"2018-11-07T13:15:33.000Z","updated":"2018-11-07T13:16:18.666Z","comments":true,"path":"2018/11/07/数据结构-7-图/","link":"","permalink":"https://ddoublewu.github.io/2018/11/07/数据结构-7-图/","excerpt":"","text":"","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://ddoublewu.github.io/categories/数据结构/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://ddoublewu.github.io/tags/笔记/"},{"name":"数据结构","slug":"数据结构","permalink":"https://ddoublewu.github.io/tags/数据结构/"},{"name":"计算机408","slug":"计算机408","permalink":"https://ddoublewu.github.io/tags/计算机408/"}]},{"title":"数据结构 (6)树与二叉树","slug":"数据结构-6-树与二叉树","date":"2018-11-07T13:14:33.000Z","updated":"2018-11-08T15:01:37.779Z","comments":true,"path":"2018/11/07/数据结构-6-树与二叉树/","link":"","permalink":"https://ddoublewu.github.io/2018/11/07/数据结构-6-树与二叉树/","excerpt":"树树的定义树是一种非线性的数据结构，它是若干结点的集合，是由唯一的根和若干棵互不相交的子树组成的。每一棵子树又是一棵树。树的定义是递归的，结点数为0的树称为空树。","text":"树树的定义树是一种非线性的数据结构，它是若干结点的集合，是由唯一的根和若干棵互不相交的子树组成的。每一棵子树又是一棵树。树的定义是递归的，结点数为0的树称为空树。 树的基本术语结点: 结点不仅包含数据元素，而且包含指向子树的分支。A,B,C等都是结点。结点的度: 结点拥有的子树个数或者分支的个数。A结点有3棵子树，所以树的度为3.树的度: 树中各结点度的最大值叶子结点: 又叫做 终端结点，指度为0的结点,如F,C,D都为叶子结点。非终端结点: 又叫做分支结点，指度不为0的结点。除了根节点之外的非终端结点，也叫做内部结点，如B,D,E孩子: 结点的子树的根，如A结点的孩子为B,C,D。双亲: 与孩子的定义相对应，如B,C,D结点的双亲都为A兄弟: 同一个双亲的孩子之间互为兄弟,如B,C,D互为兄弟祖先: 从根到某结点的路径上的所有结点，都是这个结点的祖先，如A,B,E都为F结点的祖先子孙: 以某结点为根的子树中的所有结点，都是该结点的子孙，如E,F为B结点的子孙树的高度（或者深度）: 树中结点的最大层次，图中树共有4层，故高度为4。结点的深度和高度: 结点的深度就是从根节点到该结点路径上的结点个数 从某结点往下走可能到达多个叶子结点，其中最长的那条路径的长度即为该结点在树中的高度。 根节点的高度为树的高度。如结点A，其高度为4，是从A到F这条路径的长度，也是整棵树的高度。 堂兄弟: 双亲在同一层的结点互为堂兄弟。如E和G互为堂兄弟。有序树: 树中结点的子树从左到右是有次序的，不能更换。无序树: 树中结点的子树没有顺序，可以随意交换。丰满树: 即理想平衡树，要求除最底层外，其他层都是满的。森林: 若干棵互不相交的输的集合。若把A去掉，剩下的3棵子树互不相交，它们组成一个森林。 树的存储结构树的存储结构最简单直观的是双亲存储结构，用一维数组就可以实现。例：数组下标表示树中的结点，数组元素的内容表示该结点的双亲结点1int tree[maxSize]; 注：树的双亲存储结构在克鲁斯卡尔算法中有重要的应用 二叉树二叉树的定义将一般的树加上两个限制条件就得到了二叉树： 每个结点多只有两棵子树，即二叉树中结点的度只能为0、1、2. 子树有左右顺序之分，不能颠倒。 满二叉树在一棵二叉树中，如果所有的分支结点都有左孩子和右孩子结点，并且叶子结点都集中在二叉树的最下一层，则这样的二叉树就是一颗满二叉树。 完全二叉树通俗的说，一棵完全二叉树一定是由一棵满二叉树从左至右、从上至下，挨个删除结点所得到的。如果跳着删除，则得到的不是完全二叉树。 二叉树的主要性质设二叉树上叶子结点数为$ n_0 $,单分支结点数为$ n_1 $,双分支结点数为$ n_2 $，则总结点数$ n=n_0+n_1+n_2 $ 非空二叉树上叶子结点数等于双分支结点数加1，即$ n_0=n_2+1 $ 在一棵二叉树中，所有结点的分支数等于单分支结点数加上双分支结点数的两倍，即总分支数为$ n_1+2n_2 $ 。 由于二叉树中除根节点之外，每个结点都有唯一的一个分支指向它，因此二叉树中有总分支数=总结点数-1(该结论对任何树都是适用的) 二叉树中总结点为&amp;n&amp;，求树中空指针的数目，可以将所有的空指针看做叶子结点，则树中原有的所有结点都成了双分支结点。因此根据性质1可知，空指针数为树中所有结点数+1，即$n+1$。 在一棵度为m的树中，叶子结点数为 $n_0=1+n_2+2n_3+…+(m-1)n_{m}$。 二叉树的第i层上最多有$2^{i-1}(i&gt;=1)$个结点 在高度（或深度）为k的二叉树最多有$ 2^{k}-1(k&gt;=1)$个结点。即满二叉树中前k层的结点个数为$2^k-1$ 有n个结点的完全二叉树，对各结点从上到下、从左到右依次编号,各结点之间有如下关系：若i为某结点a的编号，则：(若编号从0开始则为括号内)如果i不等于1(0)，则a的双亲结点的编号为⌊i/2⌋(⌈i/2⌉-1)如果2i&lt;=n,则a左孩子的编号为2i(2i+1);如果2i&gt;n；则a无左孩子如果2i+1&lt;=n，则a右孩子的编号为2i+1(2i+2)；如果2i+1&gt;n，则a无右孩子注：开口向下表示大于真实值的最小整数。，开口向上表示小于真实值的最大整数 给定n个结点，能构成n个结点，能构成h(n)种不同的二叉树，$ h(n)= \\frac{1}{n+1}C^{n}_{2n} $ 具有n(n&gt;=1)个结点的完全二叉树的高度（或深度）为$log_2n+1$ (另一种为$log_2(n+1)$) 二叉树的存储结构顺序存储结构顺序存储结构即是用一个数组来存储一棵二叉树，这种存储方式最适合于完全二叉树，用于存储一般二叉树会浪费大量的存储空间。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://ddoublewu.github.io/categories/数据结构/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://ddoublewu.github.io/tags/笔记/"},{"name":"数据结构","slug":"数据结构","permalink":"https://ddoublewu.github.io/tags/数据结构/"},{"name":"计算机408","slug":"计算机408","permalink":"https://ddoublewu.github.io/tags/计算机408/"}]},{"title":"数据结构 (5)数组、矩阵与广义表","slug":"数据结构-5-数组、矩阵与广义表","date":"2018-11-06T14:48:40.000Z","updated":"2018-11-07T16:19:04.462Z","comments":true,"path":"2018/11/06/数据结构-5-数组、矩阵与广义表/","link":"","permalink":"https://ddoublewu.github.io/2018/11/06/数据结构-5-数组、矩阵与广义表/","excerpt":"","text":"数组","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://ddoublewu.github.io/categories/数据结构/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://ddoublewu.github.io/tags/笔记/"},{"name":"数据结构","slug":"数据结构","permalink":"https://ddoublewu.github.io/tags/数据结构/"},{"name":"计算机408","slug":"计算机408","permalink":"https://ddoublewu.github.io/tags/计算机408/"}]},{"title":"KMP算法","slug":"KMP算法","date":"2018-11-01T09:50:07.000Z","updated":"2018-11-01T10:46:36.650Z","comments":true,"path":"2018/11/01/KMP算法/","link":"","permalink":"https://ddoublewu.github.io/2018/11/01/KMP算法/","excerpt":"","text":"KMP算法设i,j分别为主串和模式串中当前参与比较的两个字符的下标当j处发生不匹配时，j重新指向的位置恰好是之前已匹配的子串前后相重合子串的长度+1，通常我们定义一个next[j]数组，其中j取1~m，m为模式串长度，表示模式串中第h个字符发生不匹配时，应从next[j]处的字符开始重新与主串比较 next数组详解","categories":[{"name":"算法","slug":"算法","permalink":"https://ddoublewu.github.io/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://ddoublewu.github.io/tags/算法/"},{"name":"数据结构","slug":"数据结构","permalink":"https://ddoublewu.github.io/tags/数据结构/"},{"name":"计算机408","slug":"计算机408","permalink":"https://ddoublewu.github.io/tags/计算机408/"}]},{"title":"数据结构 (4)串","slug":"数据结构-4-串","date":"2018-11-01T07:37:23.000Z","updated":"2018-11-06T14:16:25.267Z","comments":true,"path":"2018/11/01/数据结构-4-串/","link":"","permalink":"https://ddoublewu.github.io/2018/11/01/数据结构-4-串/","excerpt":"串的定义串是零个或多个字符组成的有限序列。串中字符的个数称为串的长度，含有零个元素的串叫做空串。串中任意连续的字符组成的子序列称为该串的子串，包含子串的串称为主串，通常用子串在主串中的第一个位置作为子串在主串中的位置。由一个或多个空格组成的串称为空格串","text":"串的定义串是零个或多个字符组成的有限序列。串中字符的个数称为串的长度，含有零个元素的串叫做空串。串中任意连续的字符组成的子序列称为该串的子串，包含子串的串称为主串，通常用子串在主串中的第一个位置作为子串在主串中的位置。由一个或多个空格组成的串称为空格串 串的存储结构定长顺序存储表示定长顺序存储表示结构体定义如下123456struct Str&#123; char str[maxSize+1]; //maxSize为已定义的常量，表示串的最大长度 //str数组长度为maxSize+1，多出一个'\\0'作为结束标记 int length;&#125; 变长分配存储表示又叫动态分配表示12345struct Str&#123; char *ch; int length; &#125; 这种存储方法在使用时，需要函数malloc来分配一个长度为length、类型的char型的连续存储空间，分配的空间可以用free()来释放 串的基本操作赋值操作123456789101112131415161718192021222324252627282930313233int strassign(Str &amp;str,char &amp;ch)&#123; if(str.ch) free(str.ch); //释放原串空间 int len = 0; char *c = ch; while(*c) &#123; ++len; ++c; &#125; if(len==0) &#123; str.ch = NULL; str.length = 0; return 1; &#125; else &#123; str.ch = (char*)malloc(sizeof(char)*(len+1)) //取len+1是为了多一个空间放'\\0' if(str.ch == NULL) return 0; else &#123; c = ch; for(int i=0;i&lt;len;++i,++c) str.ch[i]=*c; str.length = len; return 1; &#125; &#125;&#125; 串比较操作串比较操作时串排序应用里的核心操作1234567int strcompare(Str s1,Str s2)&#123; for(int i=0;i&lt;s1.length&amp;&amp;i&lt;s2.length;++i) if(s1.ch[i]!=s2.ch[i]) return s1.ch[i]-s2.ch[i]; return s1.length - s2.length; //返回两串相等标记&#125; 串连接操作将两个串首尾相接，合并成一个字符串的操作称为串连接操作12345678910111213141516171819202122232425int concat(Str &amp;str,Str str1,Str str2)&#123; if(str.ch) &#123; free(str.ch); str.ch = NULL; &#125; str.ch = (char*)mallco(sizeof(char)*(str1.length+str2.length+1)); if (str.ch == NULL) return 0; int i=0; while(i&lt;str1.length) &#123; str.ch[i] = str1.ch[i]; ++i; &#125; int j=0; while(j&lt;str2.length) &#123; str.ch[i+j] = str2.ch[j]; ++j; &#125; str.length = str1.length+str2.length; return 1; &#125; 求子串操作求str串中从pos位置开始，长度为len的子串，子串由substr返回给用户123456789101112131415161718192021222324252627282930int substring(Str&amp; substr,Str str,int pos,int len)&#123; if(pos&lt;0||pos&gt;=str.length||len&lt;0||len&gt;str.length-pos) return 0; if(substr.ch) &#123; free(substr.ch); substr.ch = NULL; &#125; if(len==0) &#123; substr.ch = NULL; substr.length = 0; return 1; &#125; else &#123; substr.ch = (char*)malloc(sizeof(char)*(len+1) int i = pos; int j = 0; while (i&lt;pos+len) &#123; substr.ch[++j] = str.ch[i]; ++i; &#125; substr.ch[j] = '\\0'; substr.length = len; return 1; &#125;&#125; 串清空操作12345678910int clearstring(Str &amp;str)&#123; if(str.ch) &#123; free(str.ch); str.ch = NULL; &#125; str.length = 0; return 1;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://ddoublewu.github.io/categories/数据结构/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://ddoublewu.github.io/tags/笔记/"},{"name":"数据结构","slug":"数据结构","permalink":"https://ddoublewu.github.io/tags/数据结构/"},{"name":"计算机408","slug":"计算机408","permalink":"https://ddoublewu.github.io/tags/计算机408/"}]},{"title":"数据结构 (3)栈和队列","slug":"数据结构-3-栈和队列","date":"2018-10-30T13:17:21.000Z","updated":"2018-11-01T07:42:23.098Z","comments":true,"path":"2018/10/30/数据结构-3-栈和队列/","link":"","permalink":"https://ddoublewu.github.io/2018/10/30/数据结构-3-栈和队列/","excerpt":"栈的基本概念 栈的定义栈是一种只能在一端进行插入或删除操作的线性表。其中允许进行插入和删除操作的一端成为栈顶(Top)。栈顶由一个称为栈顶指针的位置指示器来指示，它是动态变化的。表的另一端称为栈底，栈底是固定不变的。栈的插入和删除操作一般称为入栈和出栈。 栈的特点栈的主要特点就是先进后出（后进先出）(FILO) 栈的存储结构栈按照存储结构可分为顺序栈和链栈，栈本质上是线性表。 栈的数学性质当n个元素以某种顺序进栈，并且可在任意时刻出栈(在满足先进后出的前提下)时，所获得的元素排列的数目N恰好满足函数Catalan()的计算，即N = \\frac{1}{n+1}C^{n}_{2n}","text":"栈的基本概念 栈的定义栈是一种只能在一端进行插入或删除操作的线性表。其中允许进行插入和删除操作的一端成为栈顶(Top)。栈顶由一个称为栈顶指针的位置指示器来指示，它是动态变化的。表的另一端称为栈底，栈底是固定不变的。栈的插入和删除操作一般称为入栈和出栈。 栈的特点栈的主要特点就是先进后出（后进先出）(FILO) 栈的存储结构栈按照存储结构可分为顺序栈和链栈，栈本质上是线性表。 栈的数学性质当n个元素以某种顺序进栈，并且可在任意时刻出栈(在满足先进后出的前提下)时，所获得的元素排列的数目N恰好满足函数Catalan()的计算，即N = \\frac{1}{n+1}C^{n}_{2n} 队列的基本概念 队列的定义队列简称队，是一种操作受限的线性表，其限制为仅允许在表的一端进行插入，在表的另一端进行删除。可进行插入的一端称为队尾(rear)，另一端称为队头(front)，向队列中插入新的元素称为入队，从队列中删除元素称为出队 队列的特点先进先出(FIFO) 队列的存储结构队列的存储结构分为顺序队和链队两种 结构体定义顺序栈定义12345struct SqStack&#123; int data[maxSize]; int top;&#125; 链栈结点定义12345struct LNode&#123; int data; LNode *next;&#125; 顺序队列定义123456struct SqQueue&#123; int data[maxSize]; int front; int rear;&#125; 链队定义队结点类型定义12345struct QNode&#123; int data; QNode *next;&#125; 链队类型定义12345struct LiQueue&#123; QNode *front; QNode *rear;&#125; 顺序栈顺序栈的要素对于顺序栈st，一共有4个要素，包含两个特殊状态和两个操作 栈空状态st.top == -1 栈满状态st.top == maxSize-1 非法状态(上溢和下溢) 元素x进栈操作先移动指针，再进入元素 12(++st.top);st.data[st.top] = x; 元素x出栈操作先取出元素，再移动指针 12x = data[st.top];--(st.top); 定义一个栈并初始化初始化一个栈，只需将栈顶指针设为-1即可12int stack[maxSize];int top = -1; 进栈代码1234567int push(int stack[],int x)&#123; if(top == maxSize-1) //栈满不能进栈 return 0; stack[++top] = x; return 1;&#125; 出栈代码1234567int pop(int stack[],int &amp;x)&#123; if(top == -1) //栈满不能进栈 return 0; x = stack[--top]; return 1;&#125; 链栈链栈的要素 栈空状态:lst-&gt;next == NULL; 栈满状态假设内存无限大的情况下，栈满情况不存在 元素进栈操作 123//其实就是头插法建立链表中的插入操作p-&gt;next = lst-&gt;next;lst-&gt;next = p; 元素出栈操作 12345//出栈元素保存在x中p = lst-&gt;next;x = p-&gt;data;lst-&gt;next = p-&gt;next;free(p); 链栈的初始化操作12345void initStack(LNode *&amp;lst)&#123; lst = (LNode*)malloc(sizeof(LNode)); //制造一个头结点 lst-&gt;next = NULL;&#125; 进栈代码12345678910void push(LNode *lst,int x)&#123; LNode *p; p = (LNode*)malloc(sizeof(LNode)); p-&gt;next = NULL; //以下三句为链表的头插法 p-&gt;data = x; p-&gt;next = lst-&gt;next; lst-&gt;next = p;&#125; 出栈代码123456789101112int pop(LNode *lst,int &amp;x)&#123; LNode *p; if(lst-&gt;next == NULL) return 0; //以下为单链表的删除操作 p = lst-&gt;next; x = p-&gt;data; lst-&gt;next = p-&gt;next; free(p); return 1;&#125; 栈的具体应用一个问题如果出现下述情况：在解决问题的过程中遇到一个子问题，但凭现有条件下不能解决它，需要记下，等待以后出现可以解决它的条件后再返回来解决。那么这种问题需要用栈来解决，因栈具有记忆的功能。 顺序栈的应用 编写算法，判断一个表达式中的括号（小括号）是否正确配对，表达式已经存入字符数组exp[]中，表达式中字符个数为n1234567891011121314151617181920212223int match(char exp[],int n)&#123; /*栈的定义与初始化*/ char stack[maxSize]; int top = -1; int i; for(i=0;i&lt;n;++i) &#123; if(exp[i] == '(') //遇到(即入栈后再处理 stack[++top] = '('; if(exp[i] == ')' &#123; if(top == -1) return 0; else --top; //栈不空就出栈 &#125; &#125; if(top==-1) return 1; else return 0;&#125; 链栈的应用顺序队循环队列假溢出: 顺序队中，front与rear指针最终到达数组末端maxSize-1处，虽然队中已经没有元素，但是仍然无法让元素进队循环队列即把数组弄成一个环，让front与rear沿着环走 循环队列的要素 队空状态:qu.rear == qu.front 队满状态:(qu.rear+1)%maxSize == qu.front 元素x进队操作:(移动队尾指针) 12qu.rear = (qu.rear+1)%maxSize;qu.data[qu.rear] = x; 元素x出队操作:（移动队首指针） 12qu.front = (qu.front+1)%maxSize;x = qu.data[qu.front]; 循环队列结点定义123456//与顺序队一样struct cycQueue&#123; int data[maxSize]; int front,rear;&#125; 初始化队列qu.rear = qu.front = 0 链队链队就是采用链式存储结构存储队列，采用单链表实现。链队的特点就是不存在队列满上溢的情况(假设内存无限大) 链队的要素 队空状态:lqu-&gt;rear==NULL或lqu-&gt;front==NULL 队满状态:不存在队满的状态（假设内存无限大的情况) 元素进队操作 12lqu-&gt;rear-&gt;next = p;lqu-&gt;rear = p; 元素出队操作 1234p = lqu-&gt;front;lqu-&gt;front = p-&gt;next;x = p-&gt;data;free(p); 初始化链队12lqu = （LiQueue*)malloc(sizeof(LiQueue));lqu-&gt;front = lqu-&gt;rear = NULL; 入队算法1234567891011121314void enQueue(LiQueue *lqu,int x)&#123; QNode *p; p = (QNode*)malloc(sizeof(QNode)); p-&gt;data = x; p-&gt;next = NULL; if(lqu-&gt;rear == NULL) lqu-&gt;rear = lqu-&gt;front = NULL; else &#123; lqu-&gt;rear-&gt;next = p; lqu-&gt;rear = p; &#125;&#125; 出队算法123456789101112131415int deQueue(LiQueue *lqu,int &amp;x)&#123; QNode *p; if(lqu-&gt;rear==NULL) return 0; else p = lqu-&gt;front; if(lqu-&gt;front == lqu-&gt;rear) lqu-&gt;rear = lqu-&gt;front = NULL; else lqu-&gt;front = lqu-&gt;front-&gt;next; x=p-&gt;data; free(p); return 1;&#125; 注: 尽量采用顺序队来解决问题，尽可能避免采用链队，除非题目明确要求要用链队 共享栈共享栈主要是为了提高内存的利用率和减少溢出的可能性而设计的。两个顺序栈共享一片连续的存储空间，这两个栈的栈底位于存储空间的两端。当两栈顶相遇时，存储空间用尽，会产生上溢 双端队列双端队列是一种插入和删除在两侧都可进行的线性表，可把双端队列看成栈底连在一起的两个两个栈。两个栈的栈顶指针向两端延伸。 例题假设元素进入双端队列的顺序是1,2,3,4输入受限的双端队列不可能输出 4,2,1,3和4,2,3,1输出受限的双端队列不可能输出 4,1,3,2和4,2,3,1两者都不可能输出 4,2,3,1","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://ddoublewu.github.io/categories/数据结构/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://ddoublewu.github.io/tags/笔记/"},{"name":"数据结构","slug":"数据结构","permalink":"https://ddoublewu.github.io/tags/数据结构/"},{"name":"计算机408","slug":"计算机408","permalink":"https://ddoublewu.github.io/tags/计算机408/"}]},{"title":"数据结构 (2)线性表","slug":"数据结构-2-线性表","date":"2018-10-27T14:45:57.000Z","updated":"2018-10-30T13:16:28.864Z","comments":true,"path":"2018/10/27/数据结构-2-线性表/","link":"","permalink":"https://ddoublewu.github.io/2018/10/27/数据结构-2-线性表/","excerpt":"线性表的定义线性表是具有相同特性数据元素的一个有限序列,线性表可以是有序的，也可以是无序的。 线性表的存储结构存储结构分为顺序存储结构和链式存储结构，前者成为顺序表，后者称为链表","text":"线性表的定义线性表是具有相同特性数据元素的一个有限序列,线性表可以是有序的，也可以是无序的。 线性表的存储结构存储结构分为顺序存储结构和链式存储结构，前者成为顺序表，后者称为链表顺序表是计算机内存中以数组形式保存的线性表 顺序表的特性 随机访问特性 顺序表要求占用连续的存储空间，一次性分配 做插入或删除操作时，需移动多个元素 存储密度=1 链表的特性 不支持随机访问 结点的存储空间利用率较顺序表稍低一些，存储密度小于1 支持存储空间的动态分配，多次分配 插入或删除元素时不需移动元素，只需修改指针 链表的形式链表由以下五种形式： 单链表带头结点的单链表头结点指针head-&gt;next == NULL时，链表为空不带头结点的单链表指针head == NULL时，链表为空 双链表在单链表的结点上增添一个指针域，指向当前结点的前驱有头结点时，指针head-&gt;next == NULL时，链表为空无头结点时，指针head == NULL时，链表为空 循环单链表循环单链表可实现从任意结点出发访问链表内的任意结点有头结点时，指针head-&gt;next == head时，链表为空无头结点时，指针head == NULL时，链表为空 循环双链表不带头结点的循环双链表head-&gt;next == head时，链表为空带头结点的满足以下任意一条即为空123head-&gt;prior == head;head-&gt;next == head&amp;&amp;head-&gt;prior == head;head-&gt;next == head||head-&gt;prior == head; 静态链表静态链表借助一维数组表示，一般链表结点空间来自于整个内存，静态链表则来自于一个结构体数组。数组中每个结点含有两个分量：一个是数据元素分量data;另一个是指针分量，指示了当前结点的直接后继在数组中的位置注:静态链表的指针是一个存储数组下标的整形变量，通过它可以找到后集结点在数组中的位置，其功能类似于指针顺序表插入/删除移动元素的个数为(n-1)/2 线性表的结构体定义顺序表的结构体定义1234#define maxSize 100//定义一个长度为n,表内元素为整数的顺序表int A[maxSize];int n; 单链表结点定义12345struct LNode&#123; int data; LNode *next; //指向后继节点的指针&#125;; 双链表结点定义123456struct DLNode&#123; int data; LNode *prior; //指向前继结点的指针 LNode *next; //指向后继节点的指针&#125; 结点是内存中一片由用户分配的存储空间，只有一个地址来表示它的存在，没有显式的名称，因此在分配链表结点空间时，定义一个指针，来存储这片空间的地址（即指针指向结点），并通常用这个指针的名称来作为结点的名称例：1LNode *A = (LNode*)malloc(sizeof(LNode)); 这里A命名了两个东西：一个是结点，另一个是指向这个结点的指针。若出现”p指向q”，此时p指代指针又”用函数free()释放p的空间”,此时p代指结点。 顺序表的操作按元素值的查找算法在顺序表中查找第一个值等于e的元素，并返回其下标12345678910int findElem(Sqlist L,int x) &#123; int i; for(i=0;i&lt;L.length;++i) &#123; if(x==L.data[i]) return i; &#125; return -1; //没找到，返回失败标记&#125; 插入数据元素的算法在顺序表的第p(0&lt;=p&lt;=length)个位置上插入新的元素e。若输入正确，即将第p个元素及以后元素右移一个位置，腾出一个空位置插入新元素，顺序表长增加1。1234567891011int insertElem(Sqlist &amp;L,int p,int e) //L本身要发生改变，所以用引用型&#123; int p,i; if(p&lt;0||p&gt;L.length||L.length == maxSize) return 0; for(i=0;i&lt;L.length;i++) //从后往前，逐个后移一个位置 L.data[i+1] = L.data[i]; L.data[p] = e; ++(L.length); return 1; //插入成功，返回1&#125; 删除元素的算法与插入相似，只需将后面的逐个向前移动1234567891011int deleteElem(Sqlist &amp;L,int p,int &amp;e) //e也发生改变&#123; int i; if(p&lt;0||p&gt;L.length||L.length == maxSize) return 0; e = data[p]; for(i=p;i&lt;L.length;i++) //逐个前移 L.data[i] = L.data[i+1]; --(L.length); return 1; &#125; 单链表的操作尾插法建立单链表假设已经有n个元素存储在数组a中12345678910111213141516void createlistR(LNode *&amp;C,int a[];int n)&#123; LNode * s,*r; //s用来指向新申请的结点，r始终指向C的终端结点 int i; C = (LNode*)malloc(sizeof(LNode)); //申请C的头结点空间 C-&gt;next = NULL; r = C; for(i=0;i&lt;n;i++) //循环申请n个结点来接收a中的一个元素 &#123; s = (LNode*)malloc(sizeof(LNode)); s-&gt;data = a[i]; r-&gt;next = s; r = r-&gt;next; //r指向终端结点，以便于接纳下一个到来的结点 &#125; r-&gt;next = NULL;&#125; 头插法建立单链表1234567891011121314void createlistF(LNode *&amp;C,int a[];int n)&#123; LNode * s; //s用来指向新申请的结点 int i; C = (LNode*)malloc(sizeof(LNode)); //申请C的头结点空间 C-&gt;next = NULL; for(i=0;i&lt;n;i++) //循环申请n个结点来接收a中的一个元素 &#123; s = (LNode*)malloc(sizeof(LNode)); s-&gt;data = a[i]; s-&gt;next = C-&gt;next; C-&gt;next = s; &#125;&#125; 头插法不断地将新结点插入前端，因此新建立的链表中元素的次序和数组a中的元素的次序是相反的。因此可以将头插法应用于将一个递增的链表转化为递减的下例为将递增的链表A,B归并为一递减的链表C1234567891011121314151617181920212223242526272829303132333435363738394041void merge(LNode *A,LNode *B,LNode *&amp;C)&#123; LNode *p = A-&gt;next; //追踪A的最小值结点 LNode *q = B-&gt;next; //追踪B的最小值结点 LNode *s; C = A; //C的头结点为A的头结点 C-&gt;next = NULL; free(B); while(p!=NULL&amp;&amp;q!=NULL) &#123; //头插法思想 if(p-&gt;data&lt;q-&gt;data) &#123; s = p; p = p-&gt;next; s-&gt;next = C-&gt;next; C-&gt;next = s; &#125; else &#123; s = q; q = q-&gt;next; s-&lt;next = C-&gt;next; C-&gt;next = s; &#125; &#125; while(p!=NULL) &#123; s = p; p = p-&gt;next; s-&gt;next = C-&gt;next; C-&gt;next = s; &#125; while(q!=NULL) &#123; s = q; q = q-&gt;next; s-&lt;next = C-&gt;next; C-&gt;next = s; &#125;&#125; 总结单链表的插入算法核心即为123//s为新结点，要插入在p结点之后s-&gt;next = p-&gt;next; p-&gt;next = s; 单链表删除的核心算法为1234//p为被删除元素前一个元素q = p-&gt;next;p-&gt;next = p-&gt;next-&gt;next;free(q); 双链表的操作采用尾插法建立双链表12345678910111213141516171819void createDlistR(DLNode *&amp;L,int a[];int n)&#123; DLNode * s,*r; int i; L = (DLNode*)malloc(sizeof(DLNode)); L-&gt;prior = NULL; L-&gt;next = NULL; r = L; //r指向终端结点 for(i = 0;i&lt;n;i++) &#123; s = (DLNode*)malloc(sizeof(DLNode)); s-&gt;data = a[i]; //采用尾插法 r-&gt;next = s; s-&gt;prior = r; r = s; &#125; r-&gt;next = NULL;&#125; 采用头插法建立双链表123456789101112131415161718void createDlistF(DLNode 8&amp;L,int a[];int n)&#123; DLNode *s; int i; L = (DLNode*)malloc(sizeof(DLNode)); L-&gt;prior = NULL; L-&gt;next = NULL; for(i = 0;i&lt;n;i++) &#123; s = (DLNode*)malloc(sizeof(DLNode)); s-&gt;data = a[i]; //采用头插法 s-&gt;next = L-&gt;next; L-&gt;next = s; s-&gt;prior = L; s-&gt;next-&gt;prior = s; &#125;&#125; 总结双链表插入结点的核心算法为：12345//假设在双链表中p所指结点之后插入一个结点s，其操作语句如下：s-&gt;next = p-&gt;next;p-&gt;next = s;s-&gt;prior = p;s-&gt;next-&gt;prior = s; //假设p指向最后一个结点，则本行可以去掉 删除结点的算法假设要删除p的后继结点1234q = p-&gt;next;p-&gt;next = q-&gt;next;q-&gt;next-&gt;prior = p;free(q); 循环链表的操作循环单链表终端结点的next结点指针指向表头结点循环双链表终端结点的next指针指向表头结点，头结点的prior指针指向表尾结点 补充：有序表中的有序是逻辑意义上的有序，指表中元素按某种规则已经排好了位置顺序表中的顺序是物理意义上的，指线性表中的元素一个接一个的存储在一片相邻的存储区域中","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://ddoublewu.github.io/categories/数据结构/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://ddoublewu.github.io/tags/笔记/"},{"name":"数据结构","slug":"数据结构","permalink":"https://ddoublewu.github.io/tags/数据结构/"},{"name":"计算机408","slug":"计算机408","permalink":"https://ddoublewu.github.io/tags/计算机408/"}]},{"title":"PAT B 1040 有几个PAT","slug":"PAT-B-1040-有几个PAT","date":"2018-10-26T14:04:41.000Z","updated":"2018-10-26T14:09:37.170Z","comments":true,"path":"2018/10/26/PAT-B-1040-有几个PAT/","link":"","permalink":"https://ddoublewu.github.io/2018/10/26/PAT-B-1040-有几个PAT/","excerpt":"（25分）字符串 APPAPT 中包含了两个单词 PAT，其中第一个 PAT 是第 2 位(P)，第 4 位(A)，第 6 位(T)；第二个 PAT 是第 3 位(P)，第 4 位(A)，第 6 位(T)。现给定字符串，问一共可以形成多少个 PAT？","text":"（25分）字符串 APPAPT 中包含了两个单词 PAT，其中第一个 PAT 是第 2 位(P)，第 4 位(A)，第 6 位(T)；第二个 PAT 是第 3 位(P)，第 4 位(A)，第 6 位(T)。现给定字符串，问一共可以形成多少个 PAT？ 输入格式：输入只有一行，包含一个字符串，长度不超过10​5​​，只包含 P、A、T 三种字母。 输出格式：在一行中输出给定字符串中包含多少个 PAT。由于结果可能比较大，只输出对 1000000007 取余数的结果。 输入样例：1APPAPT 输出样例：12 关键点： 对PAT数量的统计 参考参考文章:(https://www.cnblogs.com/asinlzm/p/4440603.html)核心思路: 如果有一个P出现，则只要知道后面有多少种AT可选，则这个P可以对应的PAT选择方法就有多少种；AT类似。 代码：12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int main()&#123; char str[100000]; int at_num, t_num, pat_num, n; pat_num = at_num = t_num = 0; long long num = 0; cin &gt;&gt; str; n = strlen(str); while (n--) &#123; if (str[n] == 'T') ++t_num; else if (str[n] == 'A') at_num += t_num; else num += at_num; if (num &gt; 1000000007) num %= 1000000007; &#125; cout &lt;&lt; num; return 0;&#125;","categories":[{"name":"PAT","slug":"PAT","permalink":"https://ddoublewu.github.io/categories/PAT/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://ddoublewu.github.io/tags/C/"},{"name":"笔记","slug":"笔记","permalink":"https://ddoublewu.github.io/tags/笔记/"},{"name":"PAT","slug":"PAT","permalink":"https://ddoublewu.github.io/tags/PAT/"}]},{"title":"数据结构 (1)绪论","slug":"数据结构-1-绪论","date":"2018-10-25T16:57:55.000Z","updated":"2018-10-29T17:13:11.386Z","comments":true,"path":"2018/10/26/数据结构-1-绪论/","link":"","permalink":"https://ddoublewu.github.io/2018/10/26/数据结构-1-绪论/","excerpt":"数据结构和算法1. 基本概念 数据数据是指所有能输入到计算机中并且被计算机程序处理的符号的总称 数据元素数据元素是数据的基本单位，可由若干数据项组成 数据项数据项是数据结构中讨论的最小单位","text":"数据结构和算法1. 基本概念 数据数据是指所有能输入到计算机中并且被计算机程序处理的符号的总称 数据元素数据元素是数据的基本单位，可由若干数据项组成 数据项数据项是数据结构中讨论的最小单位 数据对象数据对象是性质相同的数据元素的集合，是数据的一个子集。例如，大写字母就是一个数据对象，大写字母数据对象是集合{‘A’,’B’,…,’Z’} 数据结构数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。数据结构包括3方面的内容：逻辑结构、存储结构和对数据的运算。 数据的逻辑结构数据的逻辑结构是对数据之间的关系的描述,归纳起来数据的逻辑结构主要由以下两大类：（1）线性结构线性结构指数据元素间存在着“一对一”的线性关系的数据结构。（2）非线性结构非线性结构中的结点存在着一对多的关系，它可以细分为树形结构和图形结构。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://ddoublewu.github.io/categories/数据结构/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://ddoublewu.github.io/tags/笔记/"},{"name":"数据结构","slug":"数据结构","permalink":"https://ddoublewu.github.io/tags/数据结构/"},{"name":"计算机408","slug":"计算机408","permalink":"https://ddoublewu.github.io/tags/计算机408/"}]},{"title":"PAT习得知识点总结","slug":"PAT习得知识点总结","date":"2018-10-25T14:29:18.000Z","updated":"2018-11-01T07:36:35.610Z","comments":true,"path":"2018/10/25/PAT习得知识点总结/","link":"","permalink":"https://ddoublewu.github.io/2018/10/25/PAT习得知识点总结/","excerpt":"整理PAT中习得的知识点 1. 精确到小数点后一位采用头文件iomanip下的setprecision()用法精确位数","text":"整理PAT中习得的知识点 1. 精确到小数点后一位采用头文件iomanip下的setprecision()用法精确位数 用法：123456789#include &lt;iomanip&gt;#include &lt;iostream&gt;using namespace std;int main()&#123; double a = 2.3333; cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(3) &lt;&lt; a; //精确到小数点后三位 return 0;&#125; 输出:12.333 2. 素数的判定素数的判定，只需查找至sqrt(num)即可 用法:123456789101112131415#include &lt;math.h&gt;#include &lt;iostream&gt;using namespace std;int main()&#123; int num = 25; int flag = 1; //做标记 for (int i = 2; i&lt;=sqrt(num); i++) &#123; if (num%i == 0) &#123; flag = 0; break; &#125; &#125; if (flag == 0) cout &lt;&lt; num &lt;&lt; \"不是素数\" &lt;&lt; endl; else cout &lt;&lt; num &lt;&lt; \"是素数\" &lt;&lt; endl; return 0;&#125; 输出:125不是素数 3. 字符转化大小写字母转化用法:12345678#include &lt;iostream&gt;using namespace std;int main()&#123; cout &lt;&lt; (char)('Z' + 32) &lt;&lt; endl; cout &lt;&lt; (char)('a' - 32) &lt;&lt; endl; return 0;&#125; 输出12zA 将单个数字字符转化为数字用法：1234567#include &lt;iostream&gt;using namespace std;int main()&#123; cout &lt;&lt; 5-('2' - 48) &lt;&lt; endl; return 0;&#125; 输出：13 数字与字符串的相互转换采用C++的stringstream,需头文件sstream 用法:123456789101112131415#include &lt;string&gt; #include &lt;sstream&gt; #include &lt;iostream&gt;using namespace std;int main()&#123; double num = 174.44; string res; stringstream ss; //数字转化为字符串 ss &lt;&lt; num; ss &gt;&gt; res; //或 res = ss.str(); cout &lt;&lt; res &lt;&lt; endl; return 0;&#125; 输出：1174.44 4. 数组中元素排序采用sort()函数，需头文件algorithm 语法描述：123sort(begin,end,cmp) //cmp参数可以没有，如果没有默认为非降序排序sort(begin,end,less&lt;data-type&gt;()); //升序sort(begin,end,greater&lt;data-type&gt;()); //降序 用法1：123456789101112#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; int A[5] = &#123; 1,5,3,4,2 &#125;; sort(A, A + 5); //升序 for (int i = 0; i&lt;5; i++) cout &lt;&lt; A[i] &lt;&lt; ' '; return 0;&#125; 输出1：11 2 3 4 5 用法2:1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;struct Mooncake &#123; int num; &#125;cakes[100];bool cmp(Mooncake a, Mooncake b)&#123; return a.num&gt;b.num; //降序&#125;int main()&#123; int i,n = 5; for (i = 0; i &lt; n; i++) cakes[i].num = i + 1; sort(cakes, cakes + n, cmp); for (i = 0; i&lt;n; i++) cout &lt;&lt; cakes[i].num; return 0;&#125; 输出2:154321 5. 输出指定位数采用printf()函数,需头文件cstdio 用法:123456789101112#include &lt;cstdio&gt;int main()&#123; int a; char s[5] = &#123; 'l','o','v','e','\\0' &#125;; a = 189; printf(\"a=%4d\\n\", a); //输出4位十进制整数，左边补空格 printf(\"a=%04d\\n\", a); //输出4位十进制整数，左边补0 printf(\"a=%-4d\\n\", a); //输出4位十进制整数，右边补空格 printf(\"s=%s\\n\", s); //输出数组字符串 return 0;&#125; 输出:1234a= 189a=0189a=189s=love 6. 对年月日大小的比较参考文章: https://blog.csdn.net/daniel960601/article/details/55261196即year 10000 + month 100 + day，即可比较大小，数值小的年龄大。 7. 四舍五入c++数学取整函数(返回值为浮点型)，需头文件math.h: ceil(x):返回不小于x的最小整数值 floor(x):返回不大于x的最小整数值 round(x):四舍五入用法：1234567891011#include &lt;math.h&gt;#include &lt;iostream&gt;using namespace std;int main()&#123; int x = 5; cout &lt;&lt; ceil(x / 2.0)&lt;&lt;endl; cout &lt;&lt; floor(x / 2.0)&lt;&lt;endl; cout &lt;&lt; round(x / 2.0)&lt;&lt;endl; return 0;&#125; 输出：123323 8. 统计字符串中的字符数时，转化为数字处理用法：1234567891011121314#include &lt;iostream&gt;using namespace std;int main()&#123; char s; int record[128] = &#123; 0 &#125;; //将所有字符转化为数字来处理 while ((s = getchar()) != '\\n') record[(int)s]++; for (int i = 0; i&lt;128; i++) &#123; if (record[i]&gt;0) cout &lt;&lt; char(i) &lt;&lt; ':' &lt;&lt; record[i]&lt;&lt;endl; &#125; return 0;&#125; 输入:1I love you 输出：12345678 :2I:1e:1l:1o:2u:1v:1y:1 9. 输入一整行字符串采用getline()函数 用法：1234567891011121314#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; char s1[10]; string s2; cin.getline(s1, 10); //输入char[] getline(cin, s2); //输入string cout &lt;&lt; s1 &lt;&lt; endl; cout &lt;&lt; s2 &lt;&lt; endl; return 0;&#125; 输入：12I love uI love you 输出：12I love uI love you 10.","categories":[{"name":"笔记","slug":"笔记","permalink":"https://ddoublewu.github.io/categories/笔记/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://ddoublewu.github.io/tags/C/"},{"name":"基础","slug":"基础","permalink":"https://ddoublewu.github.io/tags/基础/"},{"name":"笔记","slug":"笔记","permalink":"https://ddoublewu.github.io/tags/笔记/"},{"name":"PAT","slug":"PAT","permalink":"https://ddoublewu.github.io/tags/PAT/"}]},{"title":"PAT B 1043 输出PATest","slug":"PAT-B-1043-输出PATest","date":"2018-10-25T14:03:04.000Z","updated":"2018-10-25T14:27:37.954Z","comments":true,"path":"2018/10/25/PAT-B-1043-输出PATest/","link":"","permalink":"https://ddoublewu.github.io/2018/10/25/PAT-B-1043-输出PATest/","excerpt":"（20分）给定一个长度不超过 $ {10^4}​​ $的、仅由英文字母构成的字符串。请将字符重新调整顺序，按 PATestPATest…. 这样的顺序输出，并忽略其它字符。当然，六种字符的个数不一定是一样多的，若某种字符已经输出完，则余下的字符仍按 PATest 的顺序打印，直到所有字符都被输出。","text":"（20分）给定一个长度不超过 $ {10^4}​​ $的、仅由英文字母构成的字符串。请将字符重新调整顺序，按 PATestPATest…. 这样的顺序输出，并忽略其它字符。当然，六种字符的个数不一定是一样多的，若某种字符已经输出完，则余下的字符仍按 PATest 的顺序打印，直到所有字符都被输出。 输入格式：输入在一行中给出一个长度不超过 ${10^4}​​$ 的、仅由英文字母构成的非空字符串。 输出格式：在一行中按题目要求输出排序后的字符串。题目保证输出非空。 输入样例：1redlesPayBestPATTopTeePHPereatitAPPT 输出样例：1PATestPATestPTetPTePePee 关键点： 建立字符数组,统计其各字符出现次数 代码：1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std;int main()&#123; int i,j,max = 0; char str[10000],A[6] = &#123;'P','A','T','e','s','t'&#125;; int num[6] = &#123;0&#125;; cin&gt;&gt;str; for(i=0;str[i]!='\\0';i++) &#123; for(j=0;j&lt;6;j++) &#123; if(str[i]==A[j]) num[j]++; &#125; &#125; for(j=0;j&lt;6;j++) &#123; if(max&lt;num[j]) max = num[j]; &#125; for(i=0;i&lt;max;i++) &#123; for(j=0;j&lt;6;j++) &#123; if(num[j]&gt;i) cout&lt;&lt;A[j]; &#125; &#125; return 0;&#125;","categories":[{"name":"PAT","slug":"PAT","permalink":"https://ddoublewu.github.io/categories/PAT/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://ddoublewu.github.io/tags/C/"},{"name":"笔记","slug":"笔记","permalink":"https://ddoublewu.github.io/tags/笔记/"},{"name":"PAT","slug":"PAT","permalink":"https://ddoublewu.github.io/tags/PAT/"}]},{"title":"PAT B 1042 字符统计","slug":"PAT-B-1042-字符统计","date":"2018-10-25T14:02:37.000Z","updated":"2018-10-25T14:15:17.224Z","comments":true,"path":"2018/10/25/PAT-B-1042-字符统计/","link":"","permalink":"https://ddoublewu.github.io/2018/10/25/PAT-B-1042-字符统计/","excerpt":"（20分）请编写程序，找出一段给定文字中出现最频繁的那个英文字母。 输入格式：输入在一行中给出一个长度不超过 1000 的字符串。字符串由 ASCII 码表中任意可见字符及空格组成，至少包含 1 个英文字母，以回车结束（回车不算在内）。","text":"（20分）请编写程序，找出一段给定文字中出现最频繁的那个英文字母。 输入格式：输入在一行中给出一个长度不超过 1000 的字符串。字符串由 ASCII 码表中任意可见字符及空格组成，至少包含 1 个英文字母，以回车结束（回车不算在内）。 输出格式：在一行中输出出现频率最高的那个英文字母及其出现次数，其间以空格分隔。如果有并列，则输出按字母序最小的那个字母。统计时不区分大小写，输出小写字母。 输入样例：1This is a simple TEST. There ARE numbers and other symbols 1&amp;2&amp;3........... 输出样例：1e 7 关键点: 将字符转化为数字处理 代码：12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;int main()&#123; char str[1000]; int i, max, k; max = k = 0; int record[128] = &#123; 0 &#125;; cin.getline(str, 1000); for (i = 0; str[i] != '\\0'; i++) &#123; if (str[i] &gt;= 'A'&amp;&amp;str[i] &lt;= 'Z') record[(int)(str[i] + 32)]++; else if (str[i] &gt;= 'a'&amp;&amp;str[i] &lt;= 'z') record[(int)str[i]]++; &#125; for (i = 0; i&lt;128; i++) &#123; if (record[i] != 0) &#123; if (max&lt;record[i]) &#123; max = record[i]; k = i; &#125; &#125; &#125; cout &lt;&lt; (char)k &lt;&lt; ' ' &lt;&lt; max; return 0;&#125;","categories":[{"name":"PAT","slug":"PAT","permalink":"https://ddoublewu.github.io/categories/PAT/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://ddoublewu.github.io/tags/C/"},{"name":"笔记","slug":"笔记","permalink":"https://ddoublewu.github.io/tags/笔记/"},{"name":"PAT","slug":"PAT","permalink":"https://ddoublewu.github.io/tags/PAT/"}]},{"title":"PAT B 1041 考试座位号","slug":"PAT-B-1041-考试座位号","date":"2018-10-25T10:47:06.000Z","updated":"2018-10-25T14:15:16.566Z","comments":true,"path":"2018/10/25/PAT-B-1041-考试座位号/","link":"","permalink":"https://ddoublewu.github.io/2018/10/25/PAT-B-1041-考试座位号/","excerpt":"（15分）每个 PAT 考生在参加考试时都会被分配两个座位号，一个是试机座位，一个是考试座位。正常情况下，考生在入场时先得到试机座位号码，入座进入试机状态后，系统会显示该考生的考试座位号码，考试时考生需要换到考试座位就座。但有些考生迟到了，试机已经结束，他们只能拿着领到的试机座位号码求助于你，从后台查出他们的考试座位号码。","text":"（15分）每个 PAT 考生在参加考试时都会被分配两个座位号，一个是试机座位，一个是考试座位。正常情况下，考生在入场时先得到试机座位号码，入座进入试机状态后，系统会显示该考生的考试座位号码，考试时考生需要换到考试座位就座。但有些考生迟到了，试机已经结束，他们只能拿着领到的试机座位号码求助于你，从后台查出他们的考试座位号码。 输入格式：输入第一行给出一个正整数 N（≤1000），随后 N 行，每行给出一个考生的信息：准考证号 试机座位号 考试座位号。其中准考证号由 14 位数字组成，座位从 1 到 N 编号。输入保证每个人的准考证号都不同，并且任何时候都不会把两个人分配到同一个座位上。考生信息之后，给出一个正整数 M（≤N），随后一行中给出 M 个待查询的试机座位号码，以空格分隔。 输出格式：对应每个需要查询的试机座位号码，在一行中输出对应考生的准考证号和考试座位号码，中间用 1 个空格分隔。 输入样例：1234567410120150912233 2 410120150912119 4 110120150912126 1 310120150912002 3 223 4 输出样例：1210120150912002 210120150912119 1 代码123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;struct People &#123; char num[14]; int test, exam;&#125;admin[1000];int main()&#123; int N, M, i, j, n; cin &gt;&gt; N; for (i = 0; i&lt;N; i++) cin &gt;&gt; admin[i].num &gt;&gt; admin[i].test &gt;&gt; admin[i].exam; cin &gt;&gt; M; for (i = 0; i&lt;M; i++) &#123; cin &gt;&gt; n; for (j = 0; j&lt;N; j++) &#123; if (admin[j].test == n) cout &lt;&lt; admin[j].num &lt;&lt; ' ' &lt;&lt; admin[j].exam &lt;&lt; endl; &#125; &#125; return 0;&#125;","categories":[{"name":"PAT","slug":"PAT","permalink":"https://ddoublewu.github.io/categories/PAT/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://ddoublewu.github.io/tags/C/"},{"name":"笔记","slug":"笔记","permalink":"https://ddoublewu.github.io/tags/笔记/"},{"name":"PAT","slug":"PAT","permalink":"https://ddoublewu.github.io/tags/PAT/"}]},{"title":"PAT B 1039 到底买不买","slug":"PAT-B-1039-到底买不买","date":"2018-10-25T10:35:29.000Z","updated":"2018-11-07T16:19:05.627Z","comments":true,"path":"2018/10/25/PAT-B-1039-到底买不买/","link":"","permalink":"https://ddoublewu.github.io/2018/10/25/PAT-B-1039-到底买不买/","excerpt":"（20分）小红想买些珠子做一串自己喜欢的珠串。卖珠子的摊主有很多串五颜六色的珠串，但是不肯把任何一串拆散了卖。于是小红要你帮忙判断一下，某串珠子里是否包含了全部自己想要的珠子？如果是，那么告诉她有多少多余的珠子；如果不是，那么告诉她缺了多少珠子。为方便起见，我们用[0-9]、[a-z]、[A-Z]范围内的字符来表示颜色。例如在图1中，第3串是小红想做的珠串；那么第1串可以买，因为包含了全部她想要的珠子，还多了8颗不需要的珠子；第2串不能买，因为没有黑色珠子，并且少了一颗红色的珠子。","text":"（20分）小红想买些珠子做一串自己喜欢的珠串。卖珠子的摊主有很多串五颜六色的珠串，但是不肯把任何一串拆散了卖。于是小红要你帮忙判断一下，某串珠子里是否包含了全部自己想要的珠子？如果是，那么告诉她有多少多余的珠子；如果不是，那么告诉她缺了多少珠子。为方便起见，我们用[0-9]、[a-z]、[A-Z]范围内的字符来表示颜色。例如在图1中，第3串是小红想做的珠串；那么第1串可以买，因为包含了全部她想要的珠子，还多了8颗不需要的珠子；第2串不能买，因为没有黑色珠子，并且少了一颗红色的珠子。 输入格式：每个输入包含 1 个测试用例。每个测试用例分别在 2 行中先后给出摊主的珠串和小红想做的珠串，两串都不超过 1000 个珠子。 输出格式：如果可以买，则在一行中输出 Yes 以及有多少多余的珠子；如果不可以买，则在一行中输出 No 以及缺了多少珠子。其间以 1 个空格分隔。 输入样例 1：12ppRYYGrrYBR2258YrR8RrY 输出样例 1：1Yes 8 输入样例 2：12ppRYYGrrYB225YrR8RrY 输出样例 2：1No 2 关键点： 将所有字符转化为数字处理 代码:1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;int main()&#123; char s; int record[128] = &#123; 0 &#125;; //将所有字符转化为数字来处理 int more, less,i; more = less = 0; while ((s = getchar())!= '\\n') record[(int)s]++; while ((s = getchar()) != '\\n') record[(int)s]--; for (i = 0; i&lt;128; i++) &#123; if (record[i]&lt;0) less -= record[i]; else if (record[i]&gt;0) more += record[i]; &#125; if (less&gt;0) cout &lt;&lt; \"No\" &lt;&lt;' '&lt;&lt; less; else cout &lt;&lt; \"Yes\" &lt;&lt;' '&lt;&lt; more; return 0;&#125;","categories":[{"name":"PAT","slug":"PAT","permalink":"https://ddoublewu.github.io/categories/PAT/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://ddoublewu.github.io/tags/C/"},{"name":"笔记","slug":"笔记","permalink":"https://ddoublewu.github.io/tags/笔记/"},{"name":"PAT","slug":"PAT","permalink":"https://ddoublewu.github.io/tags/PAT/"}]},{"title":"PAT B 1038 统计同成绩学生","slug":"PAT-B-1038-统计同成绩学生","date":"2018-10-23T16:14:41.000Z","updated":"2018-10-25T14:28:24.729Z","comments":true,"path":"2018/10/24/PAT-B-1038-统计同成绩学生/","link":"","permalink":"https://ddoublewu.github.io/2018/10/24/PAT-B-1038-统计同成绩学生/","excerpt":"（20分）本题要求读入 N 名学生的成绩，将获得某一给定分数的学生人数输出。 输入格式：输入在第 1 行给出不超过 ${10^​5​​} $的正整数 N，即学生总人数。随后一行给出 N 名学生的百分制整数成绩，中间以空格分隔。最后一行给出要查询的分数个数 K（不超过 N 的正整数），随后是 K 个分数，中间以空格分隔。","text":"（20分）本题要求读入 N 名学生的成绩，将获得某一给定分数的学生人数输出。 输入格式：输入在第 1 行给出不超过 ${10^​5​​} $的正整数 N，即学生总人数。随后一行给出 N 名学生的百分制整数成绩，中间以空格分隔。最后一行给出要查询的分数个数 K（不超过 N 的正整数），随后是 K 个分数，中间以空格分隔。 输出格式：在一行中按查询顺序给出得分等于指定分数的学生人数，中间以空格分隔，但行末不得有多余空格。 输入样例：1231060 75 90 55 75 99 82 90 75 503 75 90 88 输出样例：13 2 0 关键点： 最后一测试点N较大，代码需简洁 按查询顺序输出 代码：123456789101112131415161718192021#include &lt;cstdio&gt;using namespace std;int main()&#123; int i, N, K, num, s[101] = &#123; 0 &#125;; //num为成绩 scanf(\"%d\", &amp;N); for (i = 0; i &lt; N; i++) &#123; scanf(\"%d\", &amp;num); s[num]++; &#125; scanf(\"%d\", &amp;K); for (i = 0; i &lt; K; i++) &#123; scanf(\"%d\", &amp;num); if (i != K - 1) printf(\"%d \", s[num]); else printf(\"%d\", s[num]); &#125; return 0;&#125;","categories":[{"name":"PAT","slug":"PAT","permalink":"https://ddoublewu.github.io/categories/PAT/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://ddoublewu.github.io/tags/C/"},{"name":"笔记","slug":"笔记","permalink":"https://ddoublewu.github.io/tags/笔记/"},{"name":"PAT","slug":"PAT","permalink":"https://ddoublewu.github.io/tags/PAT/"}]},{"title":"PAT B 1037 在霍格沃茨找零钱","slug":"PAT-B-1037-在霍格沃茨找零钱","date":"2018-10-23T16:14:15.000Z","updated":"2018-10-23T16:33:43.485Z","comments":true,"path":"2018/10/24/PAT-B-1037-在霍格沃茨找零钱/","link":"","permalink":"https://ddoublewu.github.io/2018/10/24/PAT-B-1037-在霍格沃茨找零钱/","excerpt":"（20分）如果你是哈利·波特迷，你会知道魔法世界有它自己的货币系统 —— 就如海格告诉哈利的：“十七个银西可(Sickle)兑一个加隆(Galleon)，二十九个纳特(Knut)兑一个西可，很容易。”现在，给定哈利应付的价钱 P 和他实付的钱 A，你的任务是写一个程序来计算他应该被找的零钱。","text":"（20分）如果你是哈利·波特迷，你会知道魔法世界有它自己的货币系统 —— 就如海格告诉哈利的：“十七个银西可(Sickle)兑一个加隆(Galleon)，二十九个纳特(Knut)兑一个西可，很容易。”现在，给定哈利应付的价钱 P 和他实付的钱 A，你的任务是写一个程序来计算他应该被找的零钱。 输入格式：输入在 1 行中分别给出 P 和 A，格式为 Galleon.Sickle.Knut，其间用 1 个空格分隔。这里 Galleon 是 [0, 10​7​​] 区间内的整数，Sickle 是 [0, 17) 区间内的整数，Knut 是 [0, 29) 区间内的整数。 输出格式：在一行中用与输入同样的格式输出哈利应该被找的零钱。如果他没带够钱，那么输出的应该是负数。 输入样例 1：110.16.27 14.1.28 输出样例 1：13.2.1 输入样例 2：114.1.28 10.16.27 输出样例 2：1-3.2.1 关键点： 没带够钱的情况 代码：1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;using namespace std;int main()&#123; int G, S, K, g, s, k; int a, b, c,x,y,z; //a,b,c分别为加隆，银西可，纳克的值 scanf(\"%d.%d.%d\", &amp;G, &amp;S, &amp;K); scanf(\"%d.%d.%d\", &amp;g, &amp;s, &amp;k); //x,y,z存储g,s,k的值，即实付的金额 x = g; y = s; z = k; c = k - K; if (c&lt;0) &#123; s--; c += 29; &#125; b = s - S; if (b&lt;0) &#123; g--; b += 17; &#125; a = g - G; if(a&gt;=0) printf(\"%d.%d.%d\", a, b, c); //没带够钱的情况 else &#123; c = K - z; if (c&lt;0) &#123; S--; c += 29; &#125; b = S - y; if (b&lt;0) &#123; G--; b += 17; &#125; a = G - x; printf(\"-%d.%d.%d\", a, b, c); &#125; return 0;&#125;","categories":[{"name":"PAT","slug":"PAT","permalink":"https://ddoublewu.github.io/categories/PAT/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://ddoublewu.github.io/tags/C/"},{"name":"笔记","slug":"笔记","permalink":"https://ddoublewu.github.io/tags/笔记/"},{"name":"PAT","slug":"PAT","permalink":"https://ddoublewu.github.io/tags/PAT/"}]},{"title":"PAT B 1036 跟奥巴马一起编程","slug":"PAT-B-1036-跟奥巴马一起编程","date":"2018-10-23T16:12:46.000Z","updated":"2018-10-23T16:33:44.663Z","comments":true,"path":"2018/10/24/PAT-B-1036-跟奥巴马一起编程/","link":"","permalink":"https://ddoublewu.github.io/2018/10/24/PAT-B-1036-跟奥巴马一起编程/","excerpt":"（15分）美国总统奥巴马不仅呼吁所有人都学习编程，甚至以身作则编写代码，成为美国历史上首位编写计算机代码的总统。2014 年底，为庆祝“计算机科学教育周”正式启动，奥巴马编写了很简单的计算机代码：在屏幕上画一个正方形。现在你也跟他一起画吧！","text":"（15分）美国总统奥巴马不仅呼吁所有人都学习编程，甚至以身作则编写代码，成为美国历史上首位编写计算机代码的总统。2014 年底，为庆祝“计算机科学教育周”正式启动，奥巴马编写了很简单的计算机代码：在屏幕上画一个正方形。现在你也跟他一起画吧！ 输入格式：输入在一行中给出正方形边长 N（3≤N≤20）和组成正方形边的某种字符 C，间隔一个空格。 输出格式：输出由给定字符 C 画出的正方形。但是注意到行间距比列间距大，所以为了让结果看上去更像正方形，我们输出的行数实际上是列数的 50%（四舍五入取整）。 输入样例：110 a 输出样例：12345aaaaaaaaaaa aa aa aaaaaaaaaaa 关键点： 四舍五入 习得的方法:c++数学取整函数(返回值为浮点型)，需头文件math.h: ceil(x):返回不小于x的最小整数值 floor(x):返回不大于x的最小整数值 round(x):四舍五入例：1234567891011#include &lt;math.h&gt;#include &lt;iostream&gt;using namespace std;int main()&#123; int x = 5; cout &lt;&lt; ceil(x / 2.0)&lt;&lt;endl; cout &lt;&lt; floor(x / 2.0)&lt;&lt;endl; cout &lt;&lt; round(x / 2.0)&lt;&lt;endl; return 0;&#125; 输出：123323 代码：1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;math.h&gt;using namespace std;int main()&#123; int N, i, j, num; char s; cin&gt;&gt;N&gt;&gt;s; num = (int)round(N/2.0); for (i = 0; i&lt;num; i++) &#123; if (i == 0 || i == num -1) &#123; for (j = 0; j&lt;N - 1; j++) cout &lt;&lt; s; cout &lt;&lt; s &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; s; for (j = 1; j&lt;N - 1; j++) cout &lt;&lt; ' '; cout &lt;&lt; s &lt;&lt; endl; &#125; &#125; return 0;&#125;","categories":[{"name":"PAT","slug":"PAT","permalink":"https://ddoublewu.github.io/categories/PAT/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://ddoublewu.github.io/tags/C/"},{"name":"笔记","slug":"笔记","permalink":"https://ddoublewu.github.io/tags/笔记/"},{"name":"PAT","slug":"PAT","permalink":"https://ddoublewu.github.io/tags/PAT/"}]},{"title":"PAT B 1032 挖掘机技术哪家强","slug":"PAT-B-1032-挖掘机技术哪家强","date":"2018-10-22T15:44:53.000Z","updated":"2018-10-22T15:50:14.099Z","comments":true,"path":"2018/10/22/PAT-B-1032-挖掘机技术哪家强/","link":"","permalink":"https://ddoublewu.github.io/2018/10/22/PAT-B-1032-挖掘机技术哪家强/","excerpt":"为了用事实说明挖掘机技术到底哪家强，PAT 组织了一场挖掘机技能大赛。现请你根据比赛结果统计出技术最强的那个学校。 输入格式：输入在第 1 行给出不超过 10​5​​ 的正整数 N，即参赛人数。随后 N 行，每行给出一位参赛者的信息和成绩，包括其所代表的学校的编号（从 1 开始连续编号）、及其比赛成绩（百分制），中间以空格分隔。","text":"为了用事实说明挖掘机技术到底哪家强，PAT 组织了一场挖掘机技能大赛。现请你根据比赛结果统计出技术最强的那个学校。 输入格式：输入在第 1 行给出不超过 10​5​​ 的正整数 N，即参赛人数。随后 N 行，每行给出一位参赛者的信息和成绩，包括其所代表的学校的编号（从 1 开始连续编号）、及其比赛成绩（百分制），中间以空格分隔。 输出格式：在一行中给出总得分最高的学校的编号、及其总分，中间以空格分隔。题目保证答案唯一，没有并列。 输入样例：123456763 652 801 1002 703 403 0 输出样例：12 150 关键点： 最后一个测试点运行时间较长，代码需简洁 习得的知识点：简单声明数组不可将变量作为size，但vector可行123456#include &lt;vector&gt;int main()&#123; int n = 1000; vector&lt;int&gt; a(n);&#125; 代码：12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main()&#123; int N, i, n, m,max = 0; //m为total数组下标，max为队伍编号最大值 int max_s = 0; //max_s为最大总分 cin &gt;&gt; N; vector&lt;int&gt; num(N), score(N),total(N); for (i = 0; i&lt;N; i++) &#123; cin&gt;&gt;num[i]&gt;&gt;score[i]; if (max &lt; num[i]) max = num[i]; m = num[i]; total[m - 1] += score[i]; &#125; for (i = 0; i&lt;max; i++) &#123; if (max_s&lt;total[i]) &#123; max_s = total[i]; n = i + 1; &#125; &#125; cout &lt;&lt; n &lt;&lt; ' ' &lt;&lt; max_s; return 0;&#125;","categories":[{"name":"PAT","slug":"PAT","permalink":"https://ddoublewu.github.io/categories/PAT/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://ddoublewu.github.io/tags/C/"},{"name":"笔记","slug":"笔记","permalink":"https://ddoublewu.github.io/tags/笔记/"},{"name":"PAT","slug":"PAT","permalink":"https://ddoublewu.github.io/tags/PAT/"}]},{"title":"PAT B 1031 查验身份证","slug":"PAT-B-1031-查验身份证","date":"2018-10-22T15:36:53.000Z","updated":"2018-10-22T15:42:52.737Z","comments":true,"path":"2018/10/22/PAT-B-1031-查验身份证/","link":"","permalink":"https://ddoublewu.github.io/2018/10/22/PAT-B-1031-查验身份证/","excerpt":"（15分）一个合法的身份证号码由17位地区、日期编号和顺序编号加1位校验码组成。校验码的计算规则如下：首先对前17位数字加权求和，权重分配为：{7，9，10，5，8，4，2，1，6，3，7，9，10，5，8，4，2}；然后将计算的和对11取模得到值Z；最后按照以下关系对应Z值与校验码M的值：Z：0 1 2 3 4 5 6 7 8 9 10M：1 0 X 9 8 7 6 5 4 3 2现在给定一些身份证号码，请你验证校验码的有效性，并输出有问题的号码。","text":"（15分）一个合法的身份证号码由17位地区、日期编号和顺序编号加1位校验码组成。校验码的计算规则如下：首先对前17位数字加权求和，权重分配为：{7，9，10，5，8，4，2，1，6，3，7，9，10，5，8，4，2}；然后将计算的和对11取模得到值Z；最后按照以下关系对应Z值与校验码M的值：Z：0 1 2 3 4 5 6 7 8 9 10M：1 0 X 9 8 7 6 5 4 3 2现在给定一些身份证号码，请你验证校验码的有效性，并输出有问题的号码。 输入格式：输入第一行给出正整数N（≤100）是输入的身份证号码的个数。随后N行，每行给出1个18位身份证号码。 输出格式：按照输入的顺序每行输出1个有问题的身份证号码。这里并不检验前17位是否合理，只检查前17位是否全为数字且最后1位校验码计算准确。如果所有号码都正常，则输出All passed。 输入样例1：12345432012419880824005612010X19890101123411010819671130186637070419881216001X 输出样例1：12312010X19890101123411010819671130186637070419881216001X 输入样例2：1232320124198808240056110108196711301862 输出样例2：1All passed 关键点： 校验码的检验 X为10 出现的错误：看题看成了输出正确的… 代码123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; int N, i, j, z; int num, n; int por[17] = &#123; 7,9,10,5,8,4,2,1,6,3,7,9,10,5,8,4,2 &#125;; char M[11] = &#123; '1','0','X','9','8','7','6','5','4','3','2'&#125;; string str, s[100]; num = n = 0; cin &gt;&gt; N; for (i = 0; i&lt;N; i++) &#123; cin &gt;&gt; str; for (j = 0; j&lt;17; j++) &#123; if (str[j] == 'X') num += 10 * por[j]; else if (str[j]&gt;='0'&amp;&amp;str[j]&lt;='9') num += (str[j] - 48)*por[j]; else &#123; num = 0; s[n++] = str; break; &#125; &#125; if (num == 0) continue; else &#123; z = num % 11; if ( M[z] != str[17]) s[n++] = str; num = 0; &#125; &#125; if (n == 0) cout &lt;&lt; \"All\" &lt;&lt; ' '&lt;&lt; \"passed\"; else &#123; for (i = 0; i&lt;n; i++) cout &lt;&lt; s[i] &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"PAT","slug":"PAT","permalink":"https://ddoublewu.github.io/categories/PAT/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://ddoublewu.github.io/tags/C/"},{"name":"笔记","slug":"笔记","permalink":"https://ddoublewu.github.io/tags/笔记/"},{"name":"PAT","slug":"PAT","permalink":"https://ddoublewu.github.io/tags/PAT/"}]},{"title":"PAT B 1028 人口普查","slug":"PAT-B-1028-人口普查","date":"2018-10-21T07:52:45.000Z","updated":"2018-10-22T15:51:44.400Z","comments":true,"path":"2018/10/21/PAT-B-1028-人口普查/","link":"","permalink":"https://ddoublewu.github.io/2018/10/21/PAT-B-1028-人口普查/","excerpt":"（20分）某城镇进行人口普查，得到了全体居民的生日。现请你写个程序，找出镇上最年长和最年轻的人。这里确保每个输入的日期都是合法的，但不一定是合理的——假设已知镇上没有超过 200 岁的老人，而今天是 2014 年 9 月 6 日，所以超过 200 岁的生日和未出生的生日都是不合理的，应该被过滤掉。","text":"（20分）某城镇进行人口普查，得到了全体居民的生日。现请你写个程序，找出镇上最年长和最年轻的人。这里确保每个输入的日期都是合法的，但不一定是合理的——假设已知镇上没有超过 200 岁的老人，而今天是 2014 年 9 月 6 日，所以超过 200 岁的生日和未出生的生日都是不合理的，应该被过滤掉。 输入格式：输入在第一行给出正整数 N，取值在(0,10​5​​]；随后 N 行，每行给出 1 个人的姓名（由不超过 5 个英文字母组成的字符串）以及按 yyyy/mm/dd（即年/月/日）格式给出的生日。题目保证最年长和最年轻的人没有并列。 输出格式：在一行中顺序输出有效生日的个数、最年长人和最年轻人的姓名，其间以空格分隔。 输入样例：1234565John 2001/05/12Tom 1814/09/06Ann 2121/01/30James 1814/09/05Steve 1967/11/20 输出样例：13 Tom John 关键点 年龄大小的比较 当没有符合要求的年龄时，输出为0 对输入的处理 习得知识点scanf的用法：参考文章：C语言函数详解对年月日大小的比较：参考文章: https://blog.csdn.net/daniel960601/article/details/55261196即year 10000 + month 100 + day，即可比较大小 代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdio&gt; #include &lt;string.h&gt;using namespace std;struct People &#123; char name[6]; int year, month, day; int total;&#125;p[100000];int main()&#123; int N, i, n = 0; int max, min; char old_name[6], young_name[6]; max = 0; min = 20140907; scanf(\"%d\", &amp;N); for (i = 0; i&lt;N; i++) &#123; scanf(\"%s %d/%d/%d\",&amp;p[i].name,&amp;p[i].year, &amp;p[i].month, &amp;p[i].day); p[i].total = p[i].year * 10000 + p[i].month * 100 + p[i].day; &#125; for (i = 0; i&lt;N; i++) &#123; if (p[i].total&gt;20140906 || p[i].total&lt;18140906) continue; else &#123; n++; if (p[i].total&gt;max) &#123; max = p[i].total; strcpy(young_name, p[i].name); &#125; if (p[i].total&lt;min) &#123; strcpy(old_name, p[i].name); min = p[i].total; &#125; &#125; &#125; if(n) printf(\"%d %s %s\", n, old_name, young_name); else printf(\"0\\n\"); return 0;&#125;","categories":[{"name":"PAT","slug":"PAT","permalink":"https://ddoublewu.github.io/categories/PAT/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://ddoublewu.github.io/tags/C/"},{"name":"笔记","slug":"笔记","permalink":"https://ddoublewu.github.io/tags/笔记/"},{"name":"PAT","slug":"PAT","permalink":"https://ddoublewu.github.io/tags/PAT/"}]},{"title":"PAT B 1021 个位数统计","slug":"PAT-B-1021-个位数统计","date":"2018-10-18T16:16:48.000Z","updated":"2018-10-30T13:40:42.744Z","comments":true,"path":"2018/10/19/PAT-B-1021-个位数统计/","link":"","permalink":"https://ddoublewu.github.io/2018/10/19/PAT-B-1021-个位数统计/","excerpt":"（15分）给定一个 k 位整数 N=d​_{k−1}10​^{k−1}+⋯+d_110​^1​​+d_​0 (0≤d_{​i​​}≤9, i=0,⋯,k−1,d_{k−1​​}>0) 请编写程序统计每种不同的个位数字出现的次数。例如：给定 N=100311，则有 2 个 0，3 个 1，和 1 个 3。","text":"（15分）给定一个 k 位整数 N=d​_{k−1}10​^{k−1}+⋯+d_110​^1​​+d_​0 (0≤d_{​i​​}≤9, i=0,⋯,k−1,d_{k−1​​}>0) 请编写程序统计每种不同的个位数字出现的次数。例如：给定 N=100311，则有 2 个 0，3 个 1，和 1 个 3。 输入格式：每个输入包含 1 个测试用例，即一个不超过 1000 位的正整数 N。 输出格式：对 N 中每一种不同的个位数字，以 D:M 的格式在一行中输出该位数字 D 及其在 N 中出现的次数 M。要求按 D 的升序输出。 输入样例：1100311 输出样例：1230:21:33:1 代码：12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; int num[10] = &#123; 0 &#125;; char dig[10] = &#123; '0','1','2','3','4','5','6','7','8','9' &#125;; string str; cin &gt;&gt; str; int i, j; for (i = 0; i&lt;str.size(); i++) &#123; for (j = 0; j&lt;10; j++) &#123; if (dig[j] == str[i]) &#123; num[j]++; break; &#125; &#125; &#125; for (i = 0; i&lt;10; i++) &#123; if(num[i]!=0) cout &lt;&lt; i &lt;&lt; ':' &lt;&lt; num[i] &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"PAT","slug":"PAT","permalink":"https://ddoublewu.github.io/categories/PAT/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://ddoublewu.github.io/tags/C/"},{"name":"笔记","slug":"笔记","permalink":"https://ddoublewu.github.io/tags/笔记/"},{"name":"PAT","slug":"PAT","permalink":"https://ddoublewu.github.io/tags/PAT/"}]},{"title":"PAT B 1020 月饼","slug":"PAT-B-1020-月饼","date":"2018-10-18T05:26:48.000Z","updated":"2018-10-18T15:19:34.000Z","comments":true,"path":"2018/10/18/PAT-B-1020-月饼/","link":"","permalink":"https://ddoublewu.github.io/2018/10/18/PAT-B-1020-月饼/","excerpt":"(25分）月饼是中国人在中秋佳节时吃的一种传统食品，不同地区有许多不同风味的月饼。现给定所有种类月饼的库存量、总售价、以及市场的最大需求量，请你计算可以获得的最大收益是多少。注意：销售时允许取出一部分库存。样例给出的情形是这样的：假如我们有 3 种月饼，其库存量分别为 18、15、10 万吨，总售价分别为 75、72、45 亿元。如果市场的最大需求量只有 20 万吨，那么我们最大收益策略应该是卖出全部 15 万吨第 2 种月饼、以及 5 万吨第 3 种月饼，获得 72 + 45/2 = 94.5（亿元）。","text":"(25分）月饼是中国人在中秋佳节时吃的一种传统食品，不同地区有许多不同风味的月饼。现给定所有种类月饼的库存量、总售价、以及市场的最大需求量，请你计算可以获得的最大收益是多少。注意：销售时允许取出一部分库存。样例给出的情形是这样的：假如我们有 3 种月饼，其库存量分别为 18、15、10 万吨，总售价分别为 75、72、45 亿元。如果市场的最大需求量只有 20 万吨，那么我们最大收益策略应该是卖出全部 15 万吨第 2 种月饼、以及 5 万吨第 3 种月饼，获得 72 + 45/2 = 94.5（亿元）。 输入格式：每个输入包含一个测试用例。每个测试用例先给出一个不超过 1000 的正整数 N 表示月饼的种类数、以及不超过 500（以万吨为单位）的正整数 D 表示市场最大需求量。随后一行给出 N 个正数表示每种月饼的库存量（以万吨为单位）；最后一行给出 N 个正数表示每种月饼的总售价（以亿元为单位）。数字间以空格分隔。 输出格式：对每组测试用例，在一行中输出最大收益，以亿元为单位并精确到小数点后 2 位。 输入样例：1233 2018 15 1075 72 45 输出样例：194.50 关键点： 精确到小数点后两位 库存与需求的关系 习得知识点：排序函数sort(begin,end,cmp)，其参数cmp的用法如下：1234567891011121314#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;bool cmp(int a, int b) &#123; return a&lt;b; //此为默认升序，若为降序，只需&gt;即可&#125;int main()&#123; int A[5] = &#123; 5,3,1,2,4 &#125;; sort(A, A + 5, cmp); for (int i = 0; i &lt; 5; i++) cout &lt;&lt; A[i] &lt;&lt; ' '; return 0;&#125; 代码：123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;algorithm&gt;using namespace std;struct Mooncake&#123; double num,total_p,unit_p; //库存量，总售价，单价&#125;cakes[1000];bool cmp(Mooncake a,Mooncake b)&#123; return a.unit_p&gt;b.unit_p; //降序&#125;int main()&#123; int i,n,maxd; double max_earn; cin&gt;&gt;n&gt;&gt;maxd; for (i=0;i&lt;n;i++) cin&gt;&gt;cakes[i].num; for (i=0;i&lt;n;i++) cin&gt;&gt;cakes[i].total_p; for (i=0;i&lt;n;i++) cakes[i].unit_p = cakes[i].total_p/cakes[i].num; sort(cakes,cakes+n,cmp); for(i=0;i&lt;n;i++) &#123; if(maxd&lt;=cakes[i].num) &#123; max_earn += cakes[i].unit_p * maxd; break; &#125; else &#123; max_earn += cakes[i].unit_p * cakes[i].num; maxd -= cakes[i].num; &#125; &#125; cout&lt;&lt;setiosflags(ios::fixed)&lt;&lt;setprecision(2)&lt;&lt;max_earn; return 0;&#125;","categories":[{"name":"PAT","slug":"PAT","permalink":"https://ddoublewu.github.io/categories/PAT/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://ddoublewu.github.io/tags/C/"},{"name":"笔记","slug":"笔记","permalink":"https://ddoublewu.github.io/tags/笔记/"},{"name":"PAT","slug":"PAT","permalink":"https://ddoublewu.github.io/tags/PAT/"}]},{"title":"PAT B 1019 数字黑洞","slug":"PAT-B-1019-数字黑洞","date":"2018-10-18T03:41:52.000Z","updated":"2018-10-18T15:19:12.345Z","comments":true,"path":"2018/10/18/PAT-B-1019-数字黑洞/","link":"","permalink":"https://ddoublewu.github.io/2018/10/18/PAT-B-1019-数字黑洞/","excerpt":"给定任一个各位数字不完全相同的 4 位正整数，如果我们先把 4 个数字按非递增排序，再按非递减排序，然后用第 1 个数字减第 2 个数字，将得到一个新的数字。一直重复这样做，我们很快会停在有“数字黑洞”之称的 6174，这个神奇的数字也叫 Kaprekar 常数。","text":"给定任一个各位数字不完全相同的 4 位正整数，如果我们先把 4 个数字按非递增排序，再按非递减排序，然后用第 1 个数字减第 2 个数字，将得到一个新的数字。一直重复这样做，我们很快会停在有“数字黑洞”之称的 6174，这个神奇的数字也叫 Kaprekar 常数。例如，我们从6767开始，将得到1234567766 - 6677 = 10899810 - 0189 = 96219621 - 1269 = 83528532 - 2358 = 61747641 - 1467 = 6174... ... 现给定任意 4 位正整数，请编写程序演示到达黑洞的过程。 输入格式：输入给出一个 (0,104​) 区间内的正整数 N。 输出格式：如果 N 的 4 位数字全相等，则在一行内输出 N - N = 0000；否则将计算的每一步在一行内输出，直到 6174 作为差出现，输出格式见样例。注意每个数字按 4 位数格式输出。 输入样例 1：16767 输出样例 1：12347766 - 6677 = 10899810 - 0189 = 96219621 - 1269 = 83528532 - 2358 = 6174 输入样例 2：12222 输出样例 2：12222 - 2222 = 0000 关键点： 每个数字按4位输出 对数字各位排序 习得知识点：sort()函数参考文章： C++sort函数的使用总结sort()函数：对给定区间所有元素进行排序需头文件alogorithm 语法描述123sort(begin,end,cmp) //cmp参数可以没有，如果没有默认为非降序排序sort(begin,end,less&lt;data-type&gt;()); //升序sort(begin,end,greater&lt;data-type&gt;()); //降序 举例：123456789101112#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; int A[5] = &#123; 1,5,3,4,2 &#125;; sort(A, A + 5); //升序 for (int i = 0; i&lt;5; i++) cout &lt;&lt; A[i] &lt;&lt; ' '; return 0;&#125; 输出：11 2 3 4 5 输出指定位数采用printf()函数,需头文件cstdio1234printf(\"a=%4d\\n\",a); //输出4位十进制整数，左边补空格printf(\"a=%04d\\n\",a); //输出4位十进制整数，左边补0printf(\"a=%-4d\\n\",a); //输出4位十进制整数，右边补空格printf(\"s[]=%s\\n\",s); //输出数组字符串 代码：注意:在vs中调试scanf需改为scanf_s123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int trans_arr(int A[]);void trans_num(int n, int A[]);int main()&#123; int num, origin, n = 0; scanf(\"%d\", &amp;num); int A[4]; int res, max, min; res = max = min = 1; origin = num; trans_num(num, A); while (res != 6174) &#123; sort(A, A + 4, less&lt;int&gt;()); min = trans_arr(A); sort(A, A + 4, greater&lt;int&gt;()); max = trans_arr(A); res = max - min; //当所有数字相等时 if (res == 0) &#123; printf(\"%04d - %04d = %04d\\n\", origin, origin, 0); return 0; &#125; printf(\"%04d - %04d = %04d\\n\", max, min, res); num = res; trans_num(num, A); &#125; return 0;&#125;int trans_arr(int A[]) //将数组转化为数字&#123; int num = 0; for (int i = 0; i &lt; 4; i++) &#123; num = num * 10 + A[i]; &#125; return num;&#125;void trans_num(int n,int A[]) //将数字转化为数组&#123; for (int i = 0; i &lt; 4; i++) &#123; A[i] = n % 10; n = n / 10; &#125;&#125;","categories":[{"name":"PAT","slug":"PAT","permalink":"https://ddoublewu.github.io/categories/PAT/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://ddoublewu.github.io/tags/C/"},{"name":"笔记","slug":"笔记","permalink":"https://ddoublewu.github.io/tags/笔记/"},{"name":"PAT","slug":"PAT","permalink":"https://ddoublewu.github.io/tags/PAT/"}]},{"title":"PAT B 1018 锤子剪刀布","slug":"PAT-B-锤子剪刀布","date":"2018-10-17T13:07:25.000Z","updated":"2018-10-17T13:38:03.968Z","comments":true,"path":"2018/10/17/PAT-B-锤子剪刀布/","link":"","permalink":"https://ddoublewu.github.io/2018/10/17/PAT-B-锤子剪刀布/","excerpt":"大家应该都会玩“锤子剪刀布”的游戏：两人同时给出手势，现给出两人的交锋记录，请统计双方的胜、平、负次数，并且给出双方分别出什么手势的胜算最大。","text":"大家应该都会玩“锤子剪刀布”的游戏：两人同时给出手势，现给出两人的交锋记录，请统计双方的胜、平、负次数，并且给出双方分别出什么手势的胜算最大。 输入格式：输入第 1 行给出正整数 N（≤10​5​​），即双方交锋的次数。随后 N 行，每行给出一次交锋的信息，即甲、乙双方同时给出的的手势。C 代表“锤子”、J 代表“剪刀”、B 代表“布”，第 1 个字母代表甲方，第 2 个代表乙方，中间有 1 个空格。 输出格式：输出第 1、2 行分别给出甲、乙的胜、平、负次数，数字间以 1 个空格分隔。第 3 行给出两个字母，分别代表甲、乙获胜次数最多的手势，中间有 1 个空格。如果解不唯一，则输出按字母序最小的解。 输入样例：123456789101110C JJ BC BB BB CC CC BJ BB CJ J 输出样例：1235 3 22 3 5B B 关键点： 若相等，输出按字母序最小的解 解决方法：建立一sign[3]数组，在其中将字母序已经排好，当次数不等时，比较得出最大项，存储其下标，若相等，则下标值默认不变，即可按照字母序输出 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;using namespace std;int main()&#123; int N, i; cin &gt;&gt; N; int equal = 0; int win, lose,m = 0; char A[100000], B[100000]; int num[6] = &#123; 0 &#125;; char sign[3] = &#123; 'B','C','J' &#125;; //输入对阵记录 for (i = 0; i&lt;N; i++) &#123; cin &gt;&gt; A[i] &gt;&gt; B[i]; &#125; for (i = 0; i&lt;N; i++) &#123; if (A[i] == B[i]) &#123; equal++; &#125; else if (A[i] == 'C') &#123; if( B[i]=='J') num[1]++; else num[3]++; &#125; else if (A[i] == 'J') &#123; if (B[i]=='B') num[2]++; else num[4]++; &#125; else if (A[i] == 'B') &#123; if (B[i]=='C') num[0]++; else num[5]++; &#125; &#125; win = num[1] + num[0] + num[2]; lose = num[3]+num[4]+num[5]; cout &lt;&lt; win &lt;&lt; ' ' &lt;&lt; equal &lt;&lt; ' ' &lt;&lt; lose &lt;&lt; endl; cout &lt;&lt; lose &lt;&lt; ' ' &lt;&lt; equal &lt;&lt; ' ' &lt;&lt; win &lt;&lt; endl; int max = 0; //处理相等时情况 for (i = 0; i&lt;3; i++) &#123; if (max &lt; num[i]) &#123; max = num[i]; m = i; &#125; &#125; cout &lt;&lt; sign[m] &lt;&lt; ' '; max = 0; m = 0; for (i=3;i&lt;6;i++) &#123; if (max &lt; num[i]) &#123; max = num[i]; m = i-3; &#125; &#125; cout&lt;&lt;sign[m]; return 0;&#125;","categories":[{"name":"PAT","slug":"PAT","permalink":"https://ddoublewu.github.io/categories/PAT/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://ddoublewu.github.io/tags/C/"},{"name":"笔记","slug":"笔记","permalink":"https://ddoublewu.github.io/tags/笔记/"},{"name":"PAT","slug":"PAT","permalink":"https://ddoublewu.github.io/tags/PAT/"}]},{"title":"PAT B 1017 A除以B","slug":"PAT-B-1017-A除以B","date":"2018-10-17T05:21:55.000Z","updated":"2018-10-17T13:38:03.015Z","comments":true,"path":"2018/10/17/PAT-B-1017-A除以B/","link":"","permalink":"https://ddoublewu.github.io/2018/10/17/PAT-B-1017-A除以B/","excerpt":"本题要求计算 A/B，其中 A 是不超过 1000 位的正整数，B 是 1 位正整数。你需要输出商数 Q 和余数 R，使得 A=B×Q+R 成立。","text":"本题要求计算 A/B，其中 A 是不超过 1000 位的正整数，B 是 1 位正整数。你需要输出商数 Q 和余数 R，使得 A=B×Q+R 成立。 输入格式：输入在一行中依次给出 A 和 B，中间以 1 空格分隔。 输出格式：在一行中依次输出 Q 和 R，中间以 1 空格分隔。 输入样例：1123456789050987654321 7 输出样例：117636684150141093474 3 关键点: 处理1000位正整数的计算 商数为0的情况 将字符转化为数字 解决方法：将其转化为除法计算，通过’0’-48这种方式将字符转化为数字，不断进位计算 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; string A; int i, B, rem; int n, digit; //digit为每一次的被除数，n为数组元素的个数 n = digit = 0; int flag = 1; //做标记 cin &gt;&gt; A &gt;&gt; B; int num[1000]; for (i = 0; A[i] != '\\0'; i++) &#123; digit += (A[i] - 48); //字符转化为数字 if (digit == B) &#123; num[n++] = 1; rem = digit = 0; &#125; else if (digit &lt; B) &#123; rem = digit; digit = digit * 10; num[n++] = 0; &#125; else &#123; if (digit % B == 0) &#123; num[n++] = digit / B; rem = 0; digit = 0; &#125; else &#123; num[n++] = digit / B; rem = digit % B; digit = rem * 10; &#125; &#125; &#125; if (n == 1) &#123; cout &lt;&lt; num[0] &lt;&lt; ' ' &lt;&lt; rem; return 0; &#125; for (i = 0; i&lt;n; i++) &#123; //从第一个非0的数开始输出 if (num[i] == 0 &amp;&amp; flag == 1) continue; else &#123; cout &lt;&lt; num[i]; flag = 0; &#125; &#125; cout &lt;&lt; ' ' &lt;&lt; rem; return 0;&#125;","categories":[{"name":"PAT","slug":"PAT","permalink":"https://ddoublewu.github.io/categories/PAT/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://ddoublewu.github.io/tags/C/"},{"name":"笔记","slug":"笔记","permalink":"https://ddoublewu.github.io/tags/笔记/"},{"name":"PAT","slug":"PAT","permalink":"https://ddoublewu.github.io/tags/PAT/"}]},{"title":"PAT B 1013 数素数","slug":"PAT-B-1013-数素数","date":"2018-10-17T04:11:32.000Z","updated":"2018-10-18T15:18:55.345Z","comments":true,"path":"2018/10/17/PAT-B-1013-数素数/","link":"","permalink":"https://ddoublewu.github.io/2018/10/17/PAT-B-1013-数素数/","excerpt":"令 P​i​​ 表示第 i 个素数。现任给两个正整数 M≤N≤104，请输出PM​​​​ 到PN的所有素数。","text":"令 P​i​​ 表示第 i 个素数。现任给两个正整数 M≤N≤104，请输出PM​​​​ 到PN的所有素数。 输入格式：输入在一行中给出 M 和 N，其间以空格分隔。 输出格式：输出从 P​ 到 P​ 的所有素数，每 10 个数字占 1 行，其间以空格分隔，但行末不得有多余空格。 输入样例：15 27 输出样例：12311 13 17 19 23 29 31 37 41 4347 53 59 61 67 71 73 79 83 8997 101 103 关键点: 判定素数 每十个数字一行 行末不得有多余空格 习得知识点:素数的判定，只需查找至sqrt(num)即可用法:123456789101112131415#include &lt;math.h&gt;#include &lt;iostream&gt;using namespace std;int main()&#123; int num = 25; int flag = 1; //做标记 for (int i = 2; i&lt;sqrt(num); i++) &#123; if (num%i == 0) &#123; flag = 0; break; &#125; &#125; if (flag == 0) cout &lt;&lt; num &lt;&lt; \"不是素数\" &lt;&lt; endl; else cout &lt;&lt; num &lt;&lt; \"是素数\" &lt;&lt; endl; return 0;&#125; 代码:123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;math.h&gt;using namespace std;int main()&#123; int M, N; cin &gt;&gt; M &gt;&gt; N; int flag = 1; //做标记 int n = 1; //素数个数 int i, num = 3; int pr_num[10000] = &#123;0&#125;; pr_num[0] = 2; while (n&lt;10000) &#123; //判定素数 for (i = 2; i&lt;=sqrt(num); i++) &#123; if (num%i == 0) &#123; flag = 0; break; &#125; &#125; if (flag == 1) pr_num[n++] = num; else flag = 1; num++; &#125; n = 1; for (i = M-1; i&lt;N-1; i++) &#123; //每十个一行 if (n % 10 == 0) cout &lt;&lt; pr_num[i] &lt;&lt; endl; else cout &lt;&lt; pr_num[i] &lt;&lt; ' '; n++; &#125; cout &lt;&lt; pr_num[i]; //行末无空格 return 0;&#125;","categories":[{"name":"PAT","slug":"PAT","permalink":"https://ddoublewu.github.io/categories/PAT/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://ddoublewu.github.io/tags/C/"},{"name":"笔记","slug":"笔记","permalink":"https://ddoublewu.github.io/tags/笔记/"},{"name":"PAT","slug":"PAT","permalink":"https://ddoublewu.github.io/tags/PAT/"}]},{"title":"PAT B 1012 数字分类","slug":"PAT-B-1012-数字分类","date":"2018-10-17T03:04:50.000Z","updated":"2018-10-25T14:36:43.946Z","comments":true,"path":"2018/10/17/PAT-B-1012-数字分类/","link":"","permalink":"https://ddoublewu.github.io/2018/10/17/PAT-B-1012-数字分类/","excerpt":"给定一系列正整数，请按要求对数字进行分类，并输出以下 5 个数字： A​1​​ = 能被 5 整除的数字中所有偶数的和； A​2​​ = 将被 5 除后余 1 的数字按给出顺序进行交错求和，即计算 n​1​​−n​2​​+n​3​​−n​4​​⋯； A​3​​ = 被 5 除后余 2 的数字的个数； A​4​​ = 被 5 除后余 3 的数字的平均数，精确到小数点后 1 位； A​5​​ = 被 5 除后余 4 的数字中最大数字。","text":"给定一系列正整数，请按要求对数字进行分类，并输出以下 5 个数字： A​1​​ = 能被 5 整除的数字中所有偶数的和； A​2​​ = 将被 5 除后余 1 的数字按给出顺序进行交错求和，即计算 n​1​​−n​2​​+n​3​​−n​4​​⋯； A​3​​ = 被 5 除后余 2 的数字的个数； A​4​​ = 被 5 除后余 3 的数字的平均数，精确到小数点后 1 位； A​5​​ = 被 5 除后余 4 的数字中最大数字。 输入格式：每个输入包含 1 个测试用例。每个测试用例先给出一个不超过 1000 的正整数 N，随后给出 N 个不超过 1000 的待分类的正整数。数字间以空格分隔。 输出格式：对给定的 N 个正整数，按题目要求计算 A​1​​~A​5​​ 并在一行中顺序输出。数字间以空格分隔，但行末不得有多余空格。若其中某一类数字不存在，则在相应位置输出 N。 输入样例 1：113 1 2 3 4 5 6 7 8 9 10 20 16 18 输出样例 1130 11 2 9.7 9 输入样例 2：18 1 2 4 5 6 7 9 16 输出样例 2：1N 11 2 N 9 关键点： 精确到小数点后一位 行末不得有多余的空格 A2可能出现求和为0的情况，但此时有数字满足A2条件 习得知识点：采用头文件iomanip下的setprecision()用法精确位数 用法：123456789#include &lt;iomanip&gt;#include &lt;iostream&gt;using namespace std;int main()&#123; double a = 2.3333; cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(3) &lt;&lt; a; //精确到小数点后三位 return 0;&#125; 输出:12.333 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;iomanip&gt;using namespace std;int main()&#123; int i, N,b; double num = 0; cin &gt;&gt; N; int k = 0; int a[5] = &#123;0&#125;; int flag = 0; for(i=0;i&lt;N;i++) &#123; cin &gt;&gt; b; if (b % 5 == 0 &amp;&amp; b%2==0) a[0] += b; else if (b % 5 == 1) &#123; if (flag == 0) &#123; a[1] += b; flag = 1; &#125; else &#123; a[1] -= b; flag = 0; &#125; k++; &#125; else if (b % 5 == 2) a[2] += 1; else if (b % 5 == 3) &#123; num += 1.0; a[3] += b; &#125; else if (b % 5 ==4) &#123; if (a[4]&lt;b) a[4] = b; &#125; &#125; for (i = 0; i&lt;4; i++) &#123; if (k&gt;0&amp;&amp;i==1&amp;&amp;a[i]==0) cout&lt;&lt; 0&lt;&lt;' '; //针对关键点3 else if (a[i] == 0) cout &lt;&lt; 'N' &lt;&lt; ' '; else if (i == 3) cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(1) &lt;&lt; a[i]/num &lt;&lt;' '; //针对关键点2，精确到小数点后一位 else cout &lt;&lt; a[i] &lt;&lt; ' '; &#125; //行末无空格 if (a[i] == 0) cout &lt;&lt; 'N'; else cout &lt;&lt; a[i]; return 0;&#125;","categories":[{"name":"PAT","slug":"PAT","permalink":"https://ddoublewu.github.io/categories/PAT/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://ddoublewu.github.io/tags/C/"},{"name":"笔记","slug":"笔记","permalink":"https://ddoublewu.github.io/tags/笔记/"},{"name":"PAT","slug":"PAT","permalink":"https://ddoublewu.github.io/tags/PAT/"}]},{"title":"C++数组","slug":"C-数组","date":"2018-10-07T01:59:35.000Z","updated":"2018-10-26T14:03:55.128Z","comments":true,"path":"2018/10/07/C-数组/","link":"","permalink":"https://ddoublewu.github.io/2018/10/07/C-数组/","excerpt":"","text":"创建数组数组是一种数据格式，能够存储多个同类型的数值，每个值都存储在一个独立的数组元素中，计算机在内存中依次存储数组的各个元素。要创建数组，可使用声明语句，数组声明应指出一下三点： 存储在每个元素中的值的类型 数组名 数组中的元素数 简单变量声明使用数组声明来创建数组时，将采用静态联编，即数组长度在编译时设置该种声明数组的通用格式如下：1typename arrayName[arraySize]; 表达式arraySize指定元素数目，可以是整形常数（如10）或const值，也可以是常量表达式（如 8*sizeof(int)），即arraySize不能是变量。ex：1int days[10]; 数组的初始化只有在定义数组的时候才可初始化，不能将一个数组赋给另一个数组：123int months[5] = &#123;1,2,3,4,5&#125;; //okayint months[5]; //okayint *p = years[5]; //okay 初始化数组时，提供的值可以少于数组的元素数目，如果只对数组的一部分进行初始化，则编译器把其他元素设为0:12int days[10] = &#123;1,2&#125;; //前两个元素为0int cards[5] = &#123;0&#125;; //全部为0 若初始化数组时arraySize为空，C++编译器将计算元素个数。ex:1short things[] = &#123;1,3,5,8&#125;; //编译器将使其things数组包含4个元素 C++11数组的初始化方法C++11中的列表初始化增加了一些功能1.初始化数组时，可以省略等号（=)1short things[4] &#123;1,2,3,4&#125;; 2.可在大括号中不包含任何东西，将所有元素设置为01float cards[4] &#123;&#125;; 3.列表初始化禁止缩窄转换12long plifs[] = &#123;25,92,3.0&#125;; //not allowedchar tlifs[] = &#123;'h','j',112&#125;; //allowed 第一条不能通过编译，因为浮点型转化为整型时缩窄操作第二条语句可以通过编译，因为虽然112是一个int值，但它在char变量的取值范围内(-128~127) 使用new创建动态数组采用new[]运算符创建数组时，将采用动态联编，即在运行时为数组分配空间，其长度也将在运行时设置。 初始化数组在C++中，只需要将数组的元素类型和元素数目告诉new即可ex:1int *p = new int [10]; //创建一个包含10个int元素的数组 new运算符返回第一个元素的地址当程序使用完new分配的内存块时，应使用delete来释放它们。对于new创建的数组，应使用以下delete来释放：1delete [] p; //方括号表示释放整个数组 如果new一个实体分配内存，则应使用delete(没有方括号)来释放 数组的使用对于第一个元素，可以使用p[0],第二个元素为p[1]ex:1234double *p = new double [2];p[0] = 1.0;p[1] = 2.0;delete [] p; 模板类vector创建vector初始化模板类vector也是一种动态数组，可以在末尾添加新数据，还可以在中间添加新数据，基本上是使用new创建动态数组的替代品，要创建vector模板对象，可使用通常的表示法来指出要使用的类型，还可用初始化参数来指出需要多少矢量ex:123456#include &lt;vector&gt;using namespace std;vector&lt;int&gt; ratings(5);int n;cin&gt;&gt;n;vector&lt;double&gt; scores(n); 由于运算符[]被重载，因此创建vector对象后，可以使用通常的数组表示法来访问每个元素:123retings[0] = 9;for (int i=0;i&lt;n;i++) cout&lt;&lt;scores[i]&lt;&lt;endl; vector基本用法所有STL容器都提供了一些基本方法，其中包括size()——返回容器中元素数目,swap()——交换两个容器的内容,begin()——返回一个指向容器中第一个元素的迭代器,end()——返回一个表示超过容器尾的迭代器。 添加元素采用 push_back()可以将元素添加到末尾ex:1234vector&lt;double&gt; scores;double temp;while (cin&gt;&gt;temp &amp;&amp; temp &gt;=0) scores.push_back(temp); 这样每次循环都会给scores对象添加一个元素，在编写或运程序时，无需了解元素的数目。只要能够取得足够的内存，程序就可以增加scores的长度。 删除元素采用erase()方法删除矢量中给定区间的元素，他接受两个迭代器参数，这些参数定义了要删除的区间。第一个迭代器指向区间的起始处，第二个迭代器位于区间终止处的后一个位置。ex:1scores.erase(scores.begin(),scores.begin()+2) //删除begin()到begin()+1的元素 该区间为前闭后开，即[begin(),end()]包含的内容为[p1,p2) 插入元素使用insert()方法插入元素，insert()接收3个参数，第一个参数指定了新元素的插入位置，第二个和第三个迭代器参数定义了被插入区间，下面的代码将矢量new_d中除第一个元素外的所有元素插入到old_v矢量的第一个元素前面:1old_v.insert(old_v.begin(),new_v.begin()+1,new_v.end()); 模板类array与数组一样，array对象的长度也是固定的，也使用栈（静态内存分配），而不是自由存储区，因此其效率与数组相同，但更方便，安全；要创建array对象，需包含array头文件 array初始化1234#include &lt;array&gt;using namespace std;array&lt;int,5&gt; ai;array&lt;double,4&gt; ad = &#123;2.0,2.1,4.3,2.3&#125;;","categories":[{"name":"C++","slug":"C","permalink":"https://ddoublewu.github.io/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://ddoublewu.github.io/tags/C/"},{"name":"基础","slug":"基础","permalink":"https://ddoublewu.github.io/tags/基础/"},{"name":"笔记","slug":"笔记","permalink":"https://ddoublewu.github.io/tags/笔记/"}]}]}