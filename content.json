{"meta":{"title":"DDoubleWu的博客","subtitle":"吴会玩","description":"致力于成为程序猿的菜鸟","author":"DDoubleWu","url":"https://ddoublewu.github.io"},"pages":[{"title":"categories","date":"2018-10-05T10:39:54.000Z","updated":"2018-10-05T10:42:33.144Z","comments":false,"path":"categories/index.html","permalink":"https://ddoublewu.github.io/categories/index.html","excerpt":"","text":""},{"title":"Hello WOrld!","date":"2018-10-04T01:22:14.000Z","updated":"2018-10-04T01:22:14.120Z","comments":true,"path":"Hello-WOrld/index.html","permalink":"https://ddoublewu.github.io/Hello-WOrld/index.html","excerpt":"","text":""},{"title":"about","date":"2018-10-05T10:40:10.000Z","updated":"2018-10-05T10:42:49.652Z","comments":false,"path":"about/index.html","permalink":"https://ddoublewu.github.io/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-10-07T02:01:13.000Z","updated":"2018-10-07T02:01:13.947Z","comments":true,"path":"tags/index-1.html","permalink":"https://ddoublewu.github.io/tags/index-1.html","excerpt":"","text":""},{"title":"tags","date":"2018-10-05T10:39:35.000Z","updated":"2018-10-05T10:42:17.024Z","comments":false,"path":"tags/index.html","permalink":"https://ddoublewu.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"README","date":"2018-10-18T04:43:26.204Z","updated":"2018-10-18T04:46:05.417Z","comments":true,"path":"2018/10/18/README/","link":"","permalink":"https://ddoublewu.github.io/2018/10/18/README/","excerpt":"","text":"DDoubleWu的博客","categories":[],"tags":[]},{"title":"PAT B 1019 数字黑洞","slug":"PAT-B-1019-数字黑洞","date":"2018-10-18T03:41:52.000Z","updated":"2018-10-18T05:15:42.273Z","comments":true,"path":"2018/10/18/PAT-B-1019-数字黑洞/","link":"","permalink":"https://ddoublewu.github.io/2018/10/18/PAT-B-1019-数字黑洞/","excerpt":"给定任一个各位数字不完全相同的 4 位正整数，如果我们先把 4 个数字按非递增排序，再按非递减排序，然后用第 1 个数字减第 2 个数字，将得到一个新的数字。一直重复这样做，我们很快会停在有“数字黑洞”之称的 6174，这个神奇的数字也叫 Kaprekar 常数。","text":"给定任一个各位数字不完全相同的 4 位正整数，如果我们先把 4 个数字按非递增排序，再按非递减排序，然后用第 1 个数字减第 2 个数字，将得到一个新的数字。一直重复这样做，我们很快会停在有“数字黑洞”之称的 6174，这个神奇的数字也叫 Kaprekar 常数。例如，我们从6767开始，将得到1234567766 - 6677 = 10899810 - 0189 = 96219621 - 1269 = 83528532 - 2358 = 61747641 - 1467 = 6174... ... 现给定任意 4 位正整数，请编写程序演示到达黑洞的过程。 输入格式：输入给出一个 (0,10​4​​) 区间内的正整数 N。 输出格式：如果 N 的 4 位数字全相等，则在一行内输出 N - N = 0000；否则将计算的每一步在一行内输出，直到 6174 作为差出现，输出格式见样例。注意每个数字按 4 位数格式输出。 输入样例 1：16767 输出样例 1：12347766 - 6677 = 10899810 - 0189 = 96219621 - 1269 = 83528532 - 2358 = 6174 输入样例 2：12222 输出样例 2：12222 - 2222 = 0000 关键点： 每个数字按4位输出 对数字各位排序 习得知识点：sort()函数参考文章： C++sort函数的使用总结sort()函数：对给定区间所有元素进行排序需头文件alogorithm 语法描述123sort(begin,end,cmp) //cmp参数可以没有，如果没有默认为非降序排序sort(begin,end,less&lt;data-type&gt;()); //升序sort(begin,end,greater&lt;data-type&gt;()); //降序 举例：123456789101112#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; int A[5] = &#123; 1,5,3,4,2 &#125;; sort(A, A + 5); //升序 for (int i = 0; i&lt;5; i++) cout &lt;&lt; A[i] &lt;&lt; ' '; return 0;&#125; 输出：11 2 3 4 5 输出指定位数采用printf()函数,需头文件cstdio1234printf(\"a=%4d\\n\",a); //输出4位十进制整数，左边补空格printf(\"a=%04d\\n\",a); //输出4位十进制整数，左边补0printf(\"a=%-4d\\n\",a); //输出4位十进制整数，右边补空格printf(\"s[]=%s\\n\",s); //输出数组字符串 代码：注意:在vs中调试scanf需改为scanf_s123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int trans_arr(int A[]);void trans_num(int n, int A[]);int main()&#123; int num, origin, n = 0; scanf(\"%d\", &amp;num); int A[4]; int res, max, min; res = max = min = 1; origin = num; trans_num(num, A); while (res != 6174) &#123; sort(A, A + 4, less&lt;int&gt;()); min = trans_arr(A); sort(A, A + 4, greater&lt;int&gt;()); max = trans_arr(A); res = max - min; //当所有数字相等时 if (res == 0) &#123; printf(\"%04d - %04d = %04d\\n\", origin, origin, 0); return 0; &#125; printf(\"%04d - %04d = %04d\\n\", max, min, res); num = res; trans_num(num, A); &#125; return 0;&#125;int trans_arr(int A[]) //将数组转化为数字&#123; int num = 0; for (int i = 0; i &lt; 4; i++) &#123; num = num * 10 + A[i]; &#125; return num;&#125;void trans_num(int n,int A[]) //将数字转化为数组&#123; for (int i = 0; i &lt; 4; i++) &#123; A[i] = n % 10; n = n / 10; &#125;&#125;","categories":[{"name":"PAT","slug":"PAT","permalink":"https://ddoublewu.github.io/categories/PAT/"}],"tags":[{"name":"PAT","slug":"PAT","permalink":"https://ddoublewu.github.io/tags/PAT/"},{"name":"C++","slug":"C","permalink":"https://ddoublewu.github.io/tags/C/"},{"name":"笔记","slug":"笔记","permalink":"https://ddoublewu.github.io/tags/笔记/"}]},{"title":"PAT B 1018 锤子剪刀布","slug":"PAT-B-锤子剪刀布","date":"2018-10-17T13:07:25.000Z","updated":"2018-10-17T13:38:03.968Z","comments":true,"path":"2018/10/17/PAT-B-锤子剪刀布/","link":"","permalink":"https://ddoublewu.github.io/2018/10/17/PAT-B-锤子剪刀布/","excerpt":"大家应该都会玩“锤子剪刀布”的游戏：两人同时给出手势，现给出两人的交锋记录，请统计双方的胜、平、负次数，并且给出双方分别出什么手势的胜算最大。","text":"大家应该都会玩“锤子剪刀布”的游戏：两人同时给出手势，现给出两人的交锋记录，请统计双方的胜、平、负次数，并且给出双方分别出什么手势的胜算最大。 输入格式：输入第 1 行给出正整数 N（≤10​5​​），即双方交锋的次数。随后 N 行，每行给出一次交锋的信息，即甲、乙双方同时给出的的手势。C 代表“锤子”、J 代表“剪刀”、B 代表“布”，第 1 个字母代表甲方，第 2 个代表乙方，中间有 1 个空格。 输出格式：输出第 1、2 行分别给出甲、乙的胜、平、负次数，数字间以 1 个空格分隔。第 3 行给出两个字母，分别代表甲、乙获胜次数最多的手势，中间有 1 个空格。如果解不唯一，则输出按字母序最小的解。 输入样例：123456789101110C JJ BC BB BB CC CC BJ BB CJ J 输出样例：1235 3 22 3 5B B 关键点： 若相等，输出按字母序最小的解 解决方法：建立一sign[3]数组，在其中将字母序已经排好，当次数不等时，比较得出最大项，存储其下标，若相等，则下标值默认不变，即可按照字母序输出 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;using namespace std;int main()&#123; int N, i; cin &gt;&gt; N; int equal = 0; int win, lose,m = 0; char A[100000], B[100000]; int num[6] = &#123; 0 &#125;; char sign[3] = &#123; 'B','C','J' &#125;; //输入对阵记录 for (i = 0; i&lt;N; i++) &#123; cin &gt;&gt; A[i] &gt;&gt; B[i]; &#125; for (i = 0; i&lt;N; i++) &#123; if (A[i] == B[i]) &#123; equal++; &#125; else if (A[i] == 'C') &#123; if( B[i]=='J') num[1]++; else num[3]++; &#125; else if (A[i] == 'J') &#123; if (B[i]=='B') num[2]++; else num[4]++; &#125; else if (A[i] == 'B') &#123; if (B[i]=='C') num[0]++; else num[5]++; &#125; &#125; win = num[1] + num[0] + num[2]; lose = num[3]+num[4]+num[5]; cout &lt;&lt; win &lt;&lt; ' ' &lt;&lt; equal &lt;&lt; ' ' &lt;&lt; lose &lt;&lt; endl; cout &lt;&lt; lose &lt;&lt; ' ' &lt;&lt; equal &lt;&lt; ' ' &lt;&lt; win &lt;&lt; endl; int max = 0; //处理相等时情况 for (i = 0; i&lt;3; i++) &#123; if (max &lt; num[i]) &#123; max = num[i]; m = i; &#125; &#125; cout &lt;&lt; sign[m] &lt;&lt; ' '; max = 0; m = 0; for (i=3;i&lt;6;i++) &#123; if (max &lt; num[i]) &#123; max = num[i]; m = i-3; &#125; &#125; cout&lt;&lt;sign[m]; return 0;&#125;","categories":[{"name":"PAT","slug":"PAT","permalink":"https://ddoublewu.github.io/categories/PAT/"}],"tags":[{"name":"PAT","slug":"PAT","permalink":"https://ddoublewu.github.io/tags/PAT/"},{"name":"C++","slug":"C","permalink":"https://ddoublewu.github.io/tags/C/"},{"name":"笔记","slug":"笔记","permalink":"https://ddoublewu.github.io/tags/笔记/"}]},{"title":"PAT B 1017 A除以B","slug":"PAT-B-1017-A除以B","date":"2018-10-17T05:21:55.000Z","updated":"2018-10-17T13:38:03.015Z","comments":true,"path":"2018/10/17/PAT-B-1017-A除以B/","link":"","permalink":"https://ddoublewu.github.io/2018/10/17/PAT-B-1017-A除以B/","excerpt":"本题要求计算 A/B，其中 A 是不超过 1000 位的正整数，B 是 1 位正整数。你需要输出商数 Q 和余数 R，使得 A=B×Q+R 成立。","text":"本题要求计算 A/B，其中 A 是不超过 1000 位的正整数，B 是 1 位正整数。你需要输出商数 Q 和余数 R，使得 A=B×Q+R 成立。 输入格式：输入在一行中依次给出 A 和 B，中间以 1 空格分隔。 输出格式：在一行中依次输出 Q 和 R，中间以 1 空格分隔。 输入样例：1123456789050987654321 7 输出样例：117636684150141093474 3 关键点: 处理1000位正整数的计算 商数为0的情况 将字符转化为数字 解决方法：将其转化为除法计算，通过’0’-48这种方式将字符转化为数字，不断进位计算 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; string A; int i, B, rem; int n, digit; //digit为每一次的被除数，n为数组元素的个数 n = digit = 0; int flag = 1; //做标记 cin &gt;&gt; A &gt;&gt; B; int num[1000]; for (i = 0; A[i] != '\\0'; i++) &#123; digit += (A[i] - 48); //字符转化为数字 if (digit == B) &#123; num[n++] = 1; rem = digit = 0; &#125; else if (digit &lt; B) &#123; rem = digit; digit = digit * 10; num[n++] = 0; &#125; else &#123; if (digit % B == 0) &#123; num[n++] = digit / B; rem = 0; digit = 0; &#125; else &#123; num[n++] = digit / B; rem = digit % B; digit = rem * 10; &#125; &#125; &#125; if (n == 1) &#123; cout &lt;&lt; num[0] &lt;&lt; ' ' &lt;&lt; rem; return 0; &#125; for (i = 0; i&lt;n; i++) &#123; //从第一个非0的数开始输出 if (num[i] == 0 &amp;&amp; flag == 1) continue; else &#123; cout &lt;&lt; num[i]; flag = 0; &#125; &#125; cout &lt;&lt; ' ' &lt;&lt; rem; return 0;&#125;","categories":[{"name":"PAT","slug":"PAT","permalink":"https://ddoublewu.github.io/categories/PAT/"}],"tags":[{"name":"PAT","slug":"PAT","permalink":"https://ddoublewu.github.io/tags/PAT/"},{"name":"C++","slug":"C","permalink":"https://ddoublewu.github.io/tags/C/"},{"name":"笔记","slug":"笔记","permalink":"https://ddoublewu.github.io/tags/笔记/"}]},{"title":"PAT B 1013 数素数","slug":"PAT-B-1013-数素数","date":"2018-10-17T04:11:32.000Z","updated":"2018-10-17T05:43:56.175Z","comments":true,"path":"2018/10/17/PAT-B-1013-数素数/","link":"","permalink":"https://ddoublewu.github.io/2018/10/17/PAT-B-1013-数素数/","excerpt":"令 P​i​​ 表示第 i 个素数。现任给两个正整数 M≤N≤104，请输出PM​​​​ 到PN的所有素数。","text":"令 P​i​​ 表示第 i 个素数。现任给两个正整数 M≤N≤104，请输出PM​​​​ 到PN的所有素数。 输入格式：输入在一行中给出 M 和 N，其间以空格分隔。 输出格式：输出从 P​M​​ 到 P​N​​ 的所有素数，每 10 个数字占 1 行，其间以空格分隔，但行末不得有多余空格。 输入样例：15 27 输出样例：12311 13 17 19 23 29 31 37 41 4347 53 59 61 67 71 73 79 83 8997 101 103 关键点: 判定素数 每十个数字一行 行末不得有多余空格 习得知识点:素数的判定，只需查找至sqrt(num)即可用法:123456789101112131415#include &lt;math.h&gt;#include &lt;iostream&gt;using namespace std;int main()&#123; int num = 25; int flag = 1; //做标记 for (int i = 2; i&lt;sqrt(num); i++) &#123; if (num%i == 0) &#123; flag = 0; break; &#125; &#125; if (flag == 0) cout &lt;&lt; num &lt;&lt; \"不是素数\" &lt;&lt; endl; else cout &lt;&lt; num &lt;&lt; \"是素数\" &lt;&lt; endl; return 0;&#125; 代码:123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;math.h&gt;using namespace std;int main()&#123; int M, N; cin &gt;&gt; M &gt;&gt; N; int flag = 1; //做标记 int n = 1; //素数个数 int i, num = 3; int pr_num[10000] = &#123;0&#125;; pr_num[0] = 2; while (n&lt;10000) &#123; //判定素数 for (i = 2; i&lt;=sqrt(num); i++) &#123; if (num%i == 0) &#123; flag = 0; break; &#125; &#125; if (flag == 1) pr_num[n++] = num; else flag = 1; num++; &#125; n = 1; for (i = M-1; i&lt;N-1; i++) &#123; //每十个一行 if (n % 10 == 0) cout &lt;&lt; pr_num[i] &lt;&lt; endl; else cout &lt;&lt; pr_num[i] &lt;&lt; ' '; n++; &#125; cout &lt;&lt; pr_num[i]; //行末无空格 return 0;&#125;","categories":[{"name":"PAT","slug":"PAT","permalink":"https://ddoublewu.github.io/categories/PAT/"}],"tags":[{"name":"PAT","slug":"PAT","permalink":"https://ddoublewu.github.io/tags/PAT/"},{"name":"C++","slug":"C","permalink":"https://ddoublewu.github.io/tags/C/"},{"name":"笔记","slug":"笔记","permalink":"https://ddoublewu.github.io/tags/笔记/"}]},{"title":"PAT B 1012 数字分类","slug":"PAT-B-1012-数字分类","date":"2018-10-17T03:04:50.000Z","updated":"2018-10-17T05:27:04.970Z","comments":true,"path":"2018/10/17/PAT-B-1012-数字分类/","link":"","permalink":"https://ddoublewu.github.io/2018/10/17/PAT-B-1012-数字分类/","excerpt":"给定一系列正整数，请按要求对数字进行分类，并输出以下 5 个数字： A​1​​ = 能被 5 整除的数字中所有偶数的和； A​2​​ = 将被 5 除后余 1 的数字按给出顺序进行交错求和，即计算 n​1​​−n​2​​+n​3​​−n​4​​⋯； A​3​​ = 被 5 除后余 2 的数字的个数； A​4​​ = 被 5 除后余 3 的数字的平均数，精确到小数点后 1 位； A​5​​ = 被 5 除后余 4 的数字中最大数字。","text":"给定一系列正整数，请按要求对数字进行分类，并输出以下 5 个数字： A​1​​ = 能被 5 整除的数字中所有偶数的和； A​2​​ = 将被 5 除后余 1 的数字按给出顺序进行交错求和，即计算 n​1​​−n​2​​+n​3​​−n​4​​⋯； A​3​​ = 被 5 除后余 2 的数字的个数； A​4​​ = 被 5 除后余 3 的数字的平均数，精确到小数点后 1 位； A​5​​ = 被 5 除后余 4 的数字中最大数字。 输入格式：每个输入包含 1 个测试用例。每个测试用例先给出一个不超过 1000 的正整数 N，随后给出 N 个不超过 1000 的待分类的正整数。数字间以空格分隔。 输出格式：对给定的 N 个正整数，按题目要求计算 A​1​​~A​5​​ 并在一行中顺序输出。数字间以空格分隔，但行末不得有多余空格。若其中某一类数字不存在，则在相应位置输出 N。 输入样例 1：113 1 2 3 4 5 6 7 8 9 10 20 16 18 输出样例 1130 11 2 9.7 9 输入样例 2：18 1 2 4 5 6 7 9 16 输出样例 2：1N 11 2 N 9 关键点： 精确到小数点后一位 行末不得有多余的空格 A2可能出现求和为0的情况，但此时有数字满足A2条件 习得知识点：采用头文件iomanip下的setprecision()用法精确位数用法：123#include &lt;iomanip&gt;double a = 2.3333;cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(3) &lt;&lt; a; //精确到小数点后三位 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;iomanip&gt;using namespace std;int main()&#123; int i, N,b; double num = 0; cin &gt;&gt; N; int k = 0; int a[5] = &#123;0&#125;; int flag = 0; for(i=0;i&lt;N;i++) &#123; cin &gt;&gt; b; if (b % 5 == 0 &amp;&amp; b%2==0) a[0] += b; else if (b % 5 == 1) &#123; if (flag == 0) &#123; a[1] += b; flag = 1; &#125; else &#123; a[1] -= b; flag = 0; &#125; k++; &#125; else if (b % 5 == 2) a[2] += 1; else if (b % 5 == 3) &#123; num += 1.0; a[3] += b; &#125; else if (b % 5 ==4) &#123; if (a[4]&lt;b) a[4] = b; &#125; &#125; for (i = 0; i&lt;4; i++) &#123; if (k&gt;0&amp;&amp;i==1&amp;&amp;a[i]==0) cout&lt;&lt; 0&lt;&lt;' '; //针对关键点3 else if (a[i] == 0) cout &lt;&lt; 'N' &lt;&lt; ' '; else if (i == 3) cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(1) &lt;&lt; a[i]/num &lt;&lt;' '; //针对关键点2，精确到小数点后一位 else cout &lt;&lt; a[i] &lt;&lt; ' '; &#125; //行末无空格 if (a[i] == 0) cout &lt;&lt; 'N'; else cout &lt;&lt; a[i]; return 0;&#125;","categories":[{"name":"PAT","slug":"PAT","permalink":"https://ddoublewu.github.io/categories/PAT/"}],"tags":[{"name":"PAT","slug":"PAT","permalink":"https://ddoublewu.github.io/tags/PAT/"},{"name":"C++","slug":"C","permalink":"https://ddoublewu.github.io/tags/C/"},{"name":"笔记","slug":"笔记","permalink":"https://ddoublewu.github.io/tags/笔记/"}]},{"title":"C++数组","slug":"C-数组","date":"2018-10-07T01:59:35.000Z","updated":"2018-10-17T04:33:43.361Z","comments":true,"path":"2018/10/07/C-数组/","link":"","permalink":"https://ddoublewu.github.io/2018/10/07/C-数组/","excerpt":"","text":"创建数组数组是一种数据格式，能够存储多个同类型的数值，每个值都存储在一个独立的数组元素中，计算机在内存中依次存储数组的各个元素。要创建数组，可使用声明语句，数组声明应指出一下三点： 存储在每个元素中的值的类型 数组名 数组中的元素数 简单变量声明使用数组声明来创建数组时，将采用静态联编，即数组长度在编译时设置该种声明数组的通用格式如下：1typename arrayName[arraySize]; 表达式arraySize指定元素数目，可以是整形常数（如10）或const值，也可以是常量表达式（如 8*sizeof(int)），即arraySize不能是变量。ex：1int days[10]; 数组的初始化只有在定义数组的时候才可初始化，不能将一个数组赋给另一个数组：123int months[5] = &#123;1,2,3,4,5&#125;; //okayint months[5]; //okayint *p = years[5]; //okay 初始化数组时，提供的值可以少于数组的元素数目，如果只对数组的一部分进行初始化，则编译器把其他元素设为0:12int days[10] = &#123;1,2&#125;; //前两个元素为0int cards[5] = &#123;0&#125;; //全部为0 若初始化数组时arraySize为空，C++编译器将计算元素个数。ex:1short things[] = &#123;1,3,5,8&#125;; //编译器将使其things数组包含4个元素 C++11数组的初始化方法C++11中的列表初始化增加了一些功能1.初始化数组时，可以省略等号（=)1short things[4] &#123;1,2,3,4&#125;; 2.可在大括号中不包含任何东西，将所有元素设置为01float cards[4] &#123;&#125;; 3.列表初始化禁止缩窄转换12long plifs[] = &#123;25,92,3.0&#125;; //not allowedchar tlifs[] = &#123;'h','j',112&#125;; //allowed 第一条不能通过编译，因为浮点型转化为整型时缩窄操作第二条语句可以通过编译，因为虽然112是一个int值，但它在char变量的取值范围内(-128~127) 使用new创建动态数组采用new[]运算符创建数组时，将采用动态联编，即在运行时为数组分配空间，其长度也将在运行时设置。 初始化数组在C++中，只需要将数组的元素类型和元素数目告诉new即可ex:1int *p = new int [10]; //创建一个包含10个int元素的数组 new运算符返回第一个元素的地址当程序使用完new分配的内存块时，应使用delete来释放它们。对于new创建的数组，应使用以下delete来释放：1delete [] p; //方括号表示释放整个数组 如果new一个实体分配内存，则应使用delete(没有方括号)来释放 数组的使用对于第一个元素，可以使用p[0],第二个元素为p[1]ex:1234double *p = new double [2];p[0] = 1.0;p[1] = 2.0;delete [] p; 模板类vector创建vector初始化模板类vector也是一种动态数组，可以在末尾添加新数据，还可以在中间添加新数据，基本上是使用new创建动态数组的替代品，要创建vector模板对象，可使用通常的表示法来指出要使用的类型，还可用初始化参数来指出需要多少矢量ex:123456#include &lt;vector&gt;using namespace std;vector&lt;int&gt; ratings(5);int n;cin&gt;&gt;n;vector&lt;double&gt; scores(n); 由于运算符[]被重载，因此创建vector对象后，可以使用通常的数组表示法来访问每个元素:123retings[0] = 9;for (int i=0;i&lt;n;i++) cout&lt;&lt;scores[i]&lt;&lt;endl; vector基本用法所有STL容器都提供了一些基本方法，其中包括size()——返回容器中元素数目,swap()——交换两个容器的内容,begin()——返回一个指向容器中第一个元素的迭代器,end()——返回一个表示超过容器尾的迭代器。 添加元素采用 push_back()可以将元素添加到末尾ex:1234vector&lt;double&gt; scores;double temp;while (cin&gt;&gt;temp &amp;&amp; temp &gt;=0) scores.push_back(temp); 这样每次循环都会给scores对象添加一个元素，在编写或运程序时，无需了解元素的数目。只要能够取得足够的内存，程序就可以增加scores的长度。 删除元素采用erase()方法删除矢量中给定区间的元素，他接受两个迭代器参数，这些参数定义了要删除的区间。第一个迭代器指向区间的起始处，第二个迭代器位于区间终止处的后一个位置。ex:1scores.erase(scores.begin(),scores.begin()+2) //删除begin()到begin()+1的元素 该区间为前闭后开，即[begin(),end()]包含的内容为[p1,p2) 插入元素使用insert()方法插入元素，insert()接收3个参数，第一个参数指定了新元素的插入位置，第二个和第三个迭代器参数定义了被插入区间，下面的代码将矢量new_d中除第一个元素外的所有元素插入到old_v矢量的第一个元素前面:1old_v.insert(old_v.begin(),new_v.begin()+1,new_v.end());","categories":[{"name":"C++","slug":"C","permalink":"https://ddoublewu.github.io/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://ddoublewu.github.io/tags/C/"},{"name":"笔记","slug":"笔记","permalink":"https://ddoublewu.github.io/tags/笔记/"},{"name":"基础","slug":"基础","permalink":"https://ddoublewu.github.io/tags/基础/"}]}]}